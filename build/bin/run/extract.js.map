{"version":3,"sources":["../../../src/bin/run/extract.js"],"names":["LOG","getVal","val","v","test","parseInt","undefined","propExtractRe","keys","makeT","type","name","description","properties","hasProps","length","tt","t","makeP","defaultValue","optional","includes","def","o","desc","p","XML","Transform","transform","enc","next","push","forEach","pType","pName","default","d","pDesc","writableObjectMode","writeOnce","stream","data","jj","Promise","r","j","on","write","removeListener","runExtract","source","extract","s","ts","typedefRe","rs","props","_","map","e","Default","D","opt","rest","pr","dn","objectMode","PassThrough","pipe","end","resolve","process","stdout","ws","err"],"mappings":"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","sourcesContent":["import { createWriteStream, createReadStream } from 'fs'\nimport createRegexTransformStream from 'restream'\nimport { Transform, PassThrough } from 'stream'\nimport mismatch from 'mismatch'\nimport catcher from '../catcher'\nimport { debuglog } from 'util'\nimport typedefRe from '../../lib/typedef/re'\nimport { getNameWithDefault } from '../../lib/typedef'\n\nconst LOG = debuglog('doc')\n\nconst getVal = (val) => {\n  let v\n  if (val == 'true') v = true\n  else if (val == 'false') v = false\n  else if (/^\\d+$/. test(val)) v = parseInt(val, 10)\n  return v !== undefined ? v : val\n}\n\nexport const propExtractRe = /^ \\* @prop {(.+?)} (\\[)?(.+?)(?:=([\"'])?(.+?)\\4)?(?:])? (.+?)(?: Default `(.+?)`.)?$/gm\nconst keys = ['type', 'opt', 'name', 'quote', 'defaultValue', 'description', 'Default']\n\nconst makeT = (type, name, description, properties) => {\n  const hasProps = properties.length\n  const tt = type && type != 'Object' ? ` type=\"${type}\"` : ''\n  const t = `  <t name=\"${name}\"${tt} desc=\"${description}\"${hasProps ? '' : ' /'}>\\n`\n  return t\n}\n\nconst makeP = (type, name, defaultValue, optional, description) => {\n  const t = ['string', 'number', 'boolean'].includes(type) ? ` ${type}` : ` type=\"${type}\"`\n  const def = defaultValue !== undefined ? ` default=\"${defaultValue}\"` : ''\n  const o = optional ? ' opt' : ''\n  const desc = description ? `>${description}</p>` : '/>'\n  const p = `    <p${o}${t} name=\"${name}\"${def}${desc}\\n`\n  return p\n}\n\nconst XML = new Transform({\n  transform({ type, name, description, properties }, enc, next) {\n    const t = makeT(type, name, description, properties)\n    this.push(t)\n    properties.forEach(({ type: pType, name: pName, default: d, description: pDesc, optional }) => {\n      const p = makeP(pType, pName, d, optional, pDesc)\n      this.push(p)\n    })\n    if (properties.length) this.push('  </t>\\n')\n    next()\n  },\n  writableObjectMode: true,\n})\n\nconst writeOnce = async (stream, data) => {\n  let jj\n  await new Promise((r, j) => {\n    jj = j\n    stream.on('error', jj)\n    stream.write(data, r)\n  })\n  stream.removeListener('error', jj)\n}\n\n/**\n * Process a JavaScript file.\n * @param {string} source Path to the source JavaScript file.\n */\nexport default async function runExtract({\n  source,\n  extract = '-',\n}) {\n  try {\n    const s = createReadStream(source)\n    const ts = createRegexTransformStream(typedefRe)\n    const rs = new Transform({\n      transform([, type, name, description, props], _, next) {\n        /** @type {Object.<string, string>[]} */\n        const p = mismatch(\n          propExtractRe,\n          props,\n          keys,\n        )\n        const properties = p.map(e => {\n          const { defaultValue: d, Default: D, opt: o, ...rest } = e\n          const pr = {\n            ...rest,\n            ...(d ? { defaultValue: getVal(d) } : {}),\n            ...(D ? { Default: getVal(D) } : {}),\n            ...(o ? { optional: true } : {}),\n          }\n          if (d || D) {\n            if (!d) {\n              const dn = getNameWithDefault(pr.name, D, pr.type)\n              LOG('%s[%s] got from Default.', name, dn)\n            }\n            else if (d != D) {\n              const dn = getNameWithDefault(pr.name, D, pr.type)\n              LOG('%s[%s] does not match Default `%s`.', name, dn, pr.Default)\n            }\n            pr.default = 'defaultValue' in pr ? pr.defaultValue : pr.Default\n            delete pr.defaultValue\n            delete pr.Default\n          }\n          return pr\n        })\n        const o = {\n          type, name, description, properties,\n        }\n        this.push(o)\n        next()\n      },\n      objectMode: true,\n    })\n\n    const stream = new PassThrough()\n\n    await writeOnce(stream, '<types>\\n')\n\n    s.pipe(ts).pipe(rs).pipe(XML).pipe(stream, { end: false })\n\n    let p = Promise.resolve()\n    if (extract == '-') {\n      stream.pipe(process.stdout)\n    } else {\n      const ws = createWriteStream(extract)\n      p = new Promise((r, j) => {\n        ws.on('close', r)\n        ws.on('error', j)\n      })\n      stream.pipe(ws)\n    }\n\n    await new Promise((r, j) => {\n      rs.on('error', e => { LOG('Error in RegexTransform'); j(e) })\n      ts.on('error', e => { LOG('Error in Transform'); j(e) })\n      s.on('error', e => { LOG('Error in Read'); j(e) })\n      XML.on('error', e => { LOG('Error in XML'); j(e) })\n      stream.on('error', e => { LOG('Error in Stream'); j(e) })\n      XML.on('end', r)\n    })\n    await writeOnce(stream, '</types>\\n')\n    await p\n  } catch (err) {\n    catcher(err)\n  }\n}\n"],"file":"extract.js"}