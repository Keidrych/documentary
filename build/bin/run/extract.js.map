{"version":3,"sources":["../../../src/bin/run/extract.js"],"names":["LOG","getVal","val","v","test","parseInt","undefined","propExtractRe","keys","makeT","type","name","description","properties","hasProps","length","tt","d","i","repeat","t","makeP","defaultValue","optional","includes","def","o","desc","p","writeOnce","stream","data","jj","Promise","r","j","on","write","removeListener","XML","Transform","constructor","writableObjectMode","_transform","enc","next","push","forEach","pType","pName","default","pDesc","Properties","objectMode","props","_","map","e","Default","D","opt","rest","pr","dn","runExtract","config","source","extract","st","s","ts","typedefRe","ps","PassThrough","xml","pipe","end","resolve","process","stdout","ws","err"],"mappings":"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","sourcesContent":["import { createWriteStream, createReadStream } from 'fs'\nimport createRegexTransformStream from 'restream'\nimport { Transform, PassThrough } from 'stream'\nimport mismatch from 'mismatch'\nimport catcher from '../catcher'\nimport { debuglog } from 'util'\nimport typedefRe from '../../lib/typedef/re'\nimport { getNameWithDefault } from '../../lib/typedef'\n\nconst LOG = debuglog('doc')\n\nconst getVal = (val) => {\n  let v\n  if (val == 'true') v = true\n  else if (val == 'false') v = false\n  else if (/^\\d+$/.test(val)) v = parseInt(val, 10)\n  return v !== undefined ? v : val\n}\n\nexport const propExtractRe = /^ \\* @prop {(.+?)} (\\[)?(.+?)(?:=([\"'])?(.+?)\\4)?(?:])?(?: (.+?))?(?: Default `(.+?)`.)?$/gm\nconst keys = ['type', 'opt', 'name', 'quote', 'defaultValue', 'description', 'Default']\n\nconst makeT = (type, name, description, properties) => {\n  const hasProps = properties.length\n  const tt = type && type != 'Object' ? ` type=\"${type}\"` : ''\n  const d = description ? ` desc=\"${description}\"` : ''\n  const i = ' '.repeat(2)\n  const t = `${i}<t name=\"${name}\"${tt}${d}${hasProps ? '' : ' /'}>\\n`\n  return t\n}\n\nconst makeP = (type, name, defaultValue, optional, description) => {\n  const t = ['string', 'number', 'boolean'].includes(type) ? ` ${type}` : ` type=\"${type}\"`\n  const def = defaultValue !== undefined ? ` default=\"${defaultValue}\"` : ''\n  const o = optional ? ' opt' : ''\n  const desc = description ? `>${description}</p>` : '/>'\n  const i = ' '.repeat(4)\n  const p = `${i}<p${o}${t} name=\"${name}\"${def}${desc}\\n`\n  return p\n}\n\nconst writeOnce = async (stream, data) => {\n  let jj\n  await new Promise((r, j) => {\n    jj = j\n    stream.on('error', jj)\n    stream.write(data, r)\n  })\n  stream.removeListener('error', jj)\n}\n\n/**\n * Writes XML.\n */\nclass XML extends Transform {\n  constructor() {\n    super({\n      writableObjectMode: true,\n    })\n  }\n  _transform({ type, name, description, properties }, enc, next) {\n    const t = makeT(type, name, description, properties)\n    this.push(t)\n    properties.forEach(({ type: pType, name: pName, default: d, description: pDesc, optional }) => {\n      const p = makeP(pType, pName, d, optional, pDesc)\n      this.push(p)\n    })\n    if (properties.length) this.push('  </t>\\n')\n    next()\n  }\n}\n\n/**\n * Parses properties from a RegExp stream.\n */\nclass Properties extends Transform {\n  constructor() {\n    super({\n      objectMode: true,\n    })\n  }\n  _transform([, type, name, description, props], _, next) {\n    /** @type {Object.<string, string>[]} */\n    const p = mismatch(\n      propExtractRe,\n      props,\n      keys,\n    )\n    const properties = p.map(e => {\n      const { defaultValue: d, Default: D, opt: o, ...rest } = e\n      const pr = {\n        ...rest,\n        ...(d ? { defaultValue: getVal(d) } : {}),\n        ...(D ? { Default: getVal(D) } : {}),\n        ...(o ? { optional: true } : {}),\n      }\n      if (d || D) {\n        if (!d) {\n          const dn = getNameWithDefault(pr.name, D, pr.type)\n          LOG('%s[%s] got from Default.', name, dn)\n        }\n        else if (d != D) {\n          const dn = getNameWithDefault(pr.name, D, pr.type)\n          LOG('%s[%s] does not match Default `%s`.', name, dn, pr.Default)\n        }\n        pr.default = 'defaultValue' in pr ? pr.defaultValue : pr.Default\n        delete pr.defaultValue\n        delete pr.Default\n      }\n      return pr\n    })\n    const o = {\n      type, name, description, properties,\n    }\n    this.push(o)\n    next()\n  }\n}\n\n/**\n * Process a JavaScript file to extract typedefs and place them in an XML file.\n * @param {Config} config Configuration object.\n * @param {string} config.source Input file from which to extract typedefs.\n * @param {string} [config.extract=\"-\"] Output file to where to write XML. `-` will write to `stdout`.\n * @param {string} [config.stream] An output stream to which to write instead of a location from `extract`.\n */\nasync function runExtract(config) {\n  const {\n    source,\n    extract = '-',\n    stream: st,\n  } = config\n  try {\n    const s = createReadStream(source)\n    const ts = createRegexTransformStream(typedefRe)\n    const ps = new Properties()\n    const stream = new PassThrough()\n    const xml = new XML()\n\n    await writeOnce(stream, '<types>\\n')\n\n    s.pipe(ts).pipe(ps).pipe(xml).pipe(stream, { end: false })\n\n    let p = Promise.resolve()\n    if (st) {\n      stream.pipe(st)\n    } else if (extract == '-') {\n      stream.pipe(process.stdout)\n    } else {\n      const ws = createWriteStream(extract)\n      p = new Promise((r, j) => {\n        ws.on('close', r)\n        ws.on('error', j)\n      })\n      stream.pipe(ws)\n    }\n\n    await new Promise((r, j) => {\n      s.on('error', e => { LOG('Error in Read'); j(e) })\n      ts.on('error', e => { LOG('Error in Transform'); j(e) })\n      ps.on('error', e => { LOG('Error in RegexTransform'); j(e) })\n      xml.on('error', e => { LOG('Error in XML'); j(e) })\n      stream.on('error', e => { LOG('Error in Stream'); j(e) })\n      xml.on('end', r)\n    })\n\n    await new Promise(r => stream.end('</types>\\n', r))\n    await p\n  } catch (err) {\n    catcher(err)\n  }\n}\n\n/**\n * @typedef {Object} Config Configuration object.\n * @prop {string} [source] Input file from which to extract typedefs.\n * @prop {string} [extract=\"-\"] Output file to where to write XML. `-` will write to `stdout`.\n * @prop {Readable} [stream] An output stream to which to write instead of a location from `extract`.\n */\n\nexport default runExtract\n"],"file":"extract.js"}