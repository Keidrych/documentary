{"version":3,"sources":["../../../src/lib/rules/typedef-md.js"],"names":["LOG","typedefMdRe","typedefMdRule","re","replacement","match","location","typeName","xml","root","length","Error","content","Root","types","typedefs","map","props","type","Type","fromXML","imports","name","from","noToc","ft","filter","mdt","_","a","toMarkdown","join","e","message"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,MAAM,oBAAS,KAAT,CAAZ;AAEO,MAAMC,cAAc,gCAApB;AAEP;;;;;;;;AAMA,MAAMC,gBAAgB;AACpBC,MAAIF,WADgB;;AAEpB,QAAMG,WAAN,CAAkBC,KAAlB,EAAyBC,QAAzB,EAAmCC,QAAnC,EAA6C;AAC3C,QAAI;AACF,YAAMC,MAAM,MAAM,aAAKF,QAAL,CAAlB;AACA,YAAMG,OAAO,oBAAY,OAAZ,EAAqBD,GAArB,CAAb;AACA,UAAI,CAACC,KAAKC,MAAV,EAAkB,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AAElB,YAAM,CAAC;AAAEC,iBAASC;AAAX,OAAD,IAAsBJ,IAA5B;AACA,YAAMK,QAAQ,oBAAY,MAAZ,EAAoBD,IAApB,CAAd;AACA,YAAME,WAAWD,MACdE,GADc,CACV,CAAC;AAAEJ,eAAF;AAAWK;AAAX,OAAD,KAAwB;AAC3B,cAAMC,OAAO,IAAIC,aAAJ,EAAb;AACAD,aAAKE,OAAL,CAAaR,OAAb,EAAsBK,KAAtB;AACA,eAAOC,IAAP;AACD,OALc,CAAjB;AAOA,YAAMG,UAAU,oBAAY,QAAZ,EAAsBR,IAAtB,EACbG,GADa,CACT,CAAC;AAAEC,eAAO;AAAEK,cAAF;AAAQC;AAAR;AAAT,OAAD,KAA+B;AAClC,cAAML,OAAO,IAAIC,aAAJ,EAAb;AACAD,aAAKE,OAAL,CAAa,EAAb,EAAiB;AAAEE,cAAF;AAAQJ,gBAAO,WAAUK,IAAK,MAAKD,IAAK,EAAxC;AAA2CE,iBAAO;AAAlD,SAAjB;AACA,eAAON,IAAP;AACD,OALa,CAAhB;AAOA,YAAMO,KAAK,CAAC,GAAGJ,OAAJ,EAAa,GAAGN,QAAhB,EACRW,MADQ,CACD,CAAC;AAAEJ;AAAF,OAAD,KAAc;AACpB,YAAIf,QAAJ,EAAc,OAAOe,QAAQf,QAAf;AACd,eAAO,IAAP;AACD,OAJQ,CAAX;AAMA,UAAIA,YAAY,CAACkB,GAAGf,MAApB,EAA4B,MAAM,IAAIC,KAAJ,CAAW,QAAOJ,QAAS,aAA3B,CAAN;AAE5B,YAAMoB,MAAMF,GACTT,GADS,CACL,CAACE,IAAD,EAAOU,CAAP,EAAUC,CAAV,KAAgB;AACnB,eAAOX,KAAKY,UAAL,CAAgBD,CAAhB,CAAP;AACD,OAHS,CAAZ;AAKA,aAAOF,IAAII,IAAJ,CAAS,MAAT,CAAP;AACD,KAnCD,CAmCE,OAAOC,CAAP,EAAU;AACVhC,UAAI,uCAAJ,EAA6CM,QAA7C,EAAuD0B,EAAEC,OAAzD;AACA,aAAO5B,KAAP;AACD;AACF;;AA1CmB,CAAtB;AA6CA;;;;eAIeH,a","sourcesContent":["import { debuglog } from 'util'\nimport extractTags from 'rexml'\nimport { read } from '..'\nimport Type from '../typedef/Type'\n\nconst LOG = debuglog('doc')\n\nexport const typedefMdRe = /^%TYPEDEF (.+?)(?: (.+?))?%$/mg\n\n/**\n * This rule is used to used to parse a typedefs XML file and place the\n * definition of a type into documentation.\n * @todo Cache extracted types from XML files.\n * @type {{re: RegExp, replacement: AsyncReplacer}}\n */\nconst typedefMdRule = {\n  re: typedefMdRe,\n  async replacement(match, location, typeName) {\n    try {\n      const xml = await read(location)\n      const root = extractTags('types', xml)\n      if (!root.length) throw new Error('XML file should contain root types element.')\n\n      const [{ content: Root }] = root\n      const types = extractTags('type', Root)\n      const typedefs = types\n        .map(({ content, props }) => {\n          const type = new Type()\n          type.fromXML(content, props)\n          return type\n        })\n\n      const imports = extractTags('import', Root)\n        .map(({ props: { name, from } }) => {\n          const type = new Type()\n          type.fromXML('', { name, type: `import('${from}').${name}`, noToc: true } )\n          return type\n        })\n\n      const ft = [...imports, ...typedefs]\n        .filter(({ name }) => {\n          if (typeName) return name == typeName\n          return true\n        })\n\n      if (typeName && !ft.length) throw new Error(`Type ${typeName} not found.`)\n\n      const mdt = ft\n        .map((type, _, a) => {\n          return type.toMarkdown(a)\n        })\n\n      return mdt.join('\\n\\n')\n    } catch (e) {\n      LOG('(%s) Could not process typedef-md: %s', location, e.message)\n      return match\n    }\n  },\n}\n\n/**\n * @typedef {import('restream').AsyncReplacer} AsyncReplacer\n */\n\nexport default typedefMdRule\n"],"file":"typedef-md.js"}