{"version":3,"sources":["../../src/lib/Toc.js"],"names":["re","rre","Toc","Transform","constructor","config","skipLevelOne","_transform","buffer","enc","next","res","b","replace","RegExp","commentRe","codeRe","match","exactMethodTitle","test","superRe","source","methodTitleRe","exec","t","level","link","length","title","l","bb","slice","filter","a","join","trim","json","args","JSON","parse","s","map","name","type","fullTitle","err","heading","p","repeat","push","lastIndex","getToc","stream","rs","pipe","promise","Catchment"],"mappings":"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","sourcesContent":["import { Transform } from 'stream'\nimport Catchment from 'catchment'\nimport { getLink, makeARegexFromRule, exactMethodTitle } from '.'\nimport { methodTitleRe, replaceTitle } from './rules/method-title'\nimport { commentRe, codeRe } from './rules'\n\nconst re = /(?:^|\\n) *(#+) *((?:(?!\\n)[\\s\\S])+)\\n/\nconst rre = makeARegexFromRule({ re })\n\nexport default class Toc extends Transform {\n  /**\n   * A transform stream which will extract the titles in the markdown document and transform them into a markdown nested list with links.\n   * @param {Config} [config] Configuration object.\n   * @param {boolean} [config.skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n   */\n  constructor(config = {}) {\n    const {\n      skipLevelOne = true,\n    } = config\n    super()\n    this.skipLevelOne = skipLevelOne\n  }\n  _transform(buffer, enc, next) {\n    let res\n    const b = `${buffer}`\n      .replace(new RegExp(commentRe, 'g'), '')\n      .replace(new RegExp(codeRe, 'g'), (match) => {\n        if (exactMethodTitle.test(match) || rre.test(match)) {\n          return match\n        }\n        return '' // ignore code blocks\n      })\n    const superRe = new RegExp(`(?:${re.source})|(?:${methodTitleRe.source})`, 'g')\n    while ((res = superRe.exec(b)) !== null) {\n      let t\n      let level\n      let link\n      if (res[1]) { // normal title regex\n        const [, { length }, title] = res\n        level = length\n        if (this.skipLevelOne && level == 1) continue\n        t = title\n        link = getLink(title)\n      } else { // the method title regex\n        try {\n          const l = res[3]\n          level = l.length\n          const bb = res.slice(4, 6).filter(a => a).join(' ').trim()\n          const json = res[7] || '[]'\n          const args = JSON.parse(json)\n          const s = args.map(([name, type]) => {\n            if (typeof type == 'string') return `${name}: ${type}`\n            return `${name}: object`\n          })\n          const fullTitle = replaceTitle(...res.slice(3)).replace(/^#+ +/, '')\n          link = getLink(fullTitle)\n          t = `\\`${bb}(${s.join(', ')})${res[6] ? `: ${res[6]}` : ''}\\``\n        } catch (err) {\n          // ok\n          continue\n        }\n      }\n      const heading = `[${t}](#${link})`\n      let s\n      if (level == 2) {\n        s = `- ${heading}`\n      } else {\n        const p = '  '.repeat(level - 2)\n        s = `${p}* ${heading}`\n      }\n      this.push(s)\n      this.push('\\n')\n    }\n    re.lastIndex = -1\n    next()\n  }\n}\n\nexport const getToc = async (stream) => {\n  const rs = new Toc()\n  stream.pipe(rs)\n  const { promise } = new Catchment({ rs })\n  const t = await promise\n  return t.trim()\n}\n\n/**\n * @typedef {Object} Config\n * @property {boolean} [skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n */\n"],"file":"Toc.js"}