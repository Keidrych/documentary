{"version":3,"sources":["../../src/lib/Toc.js"],"names":["re","Toc","Transform","constructor","config","skipLevelOne","_transform","buffer","enc","next","res","matches","b","replace","RegExp","commentRe","methodTitleRe","match","push","codeRe","isMatch","test","shift","rre","source","exec","t","level","link","length","title","l","slice","filter","a","join","trim","json","args","JSON","parse","s","map","name","type","fullTitle","err","heading","p","repeat","lastIndex","getToc","stream","rs","pipe","promise","Catchment"],"mappings":"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","sourcesContent":["import { Transform } from 'stream'\nimport Catchment from 'catchment'\nimport { getLink } from '.'\nimport { methodTitleRe, replaceTitle } from './rules/method-title'\nimport { commentRe, codeRe } from './rules'\n\nconst re = /(?:^|\\n) *(#+) *((?:(?!\\n)[\\s\\S])+)\\n/\n\nexport default class Toc extends Transform {\n  /**\n   * A transform stream which will extract the titles in the markdown document and transform them into a markdown nested list with links.\n   * @param {Config} [config] Configuration object.\n   * @param {boolean} [config.skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n   */\n  constructor(config = {}) {\n    const {\n      skipLevelOne = true,\n    } = config\n    super()\n    this.skipLevelOne = skipLevelOne\n  }\n  _transform(buffer, enc, next) {\n    let res\n    const matches = []\n    const b = `${buffer}`\n      .replace(new RegExp(commentRe, 'g'), '')\n      .replace(new RegExp(methodTitleRe, 'g'), (match) => {\n        matches.push(match)\n        return match\n      })\n      .replace(new RegExp(codeRe, 'g'), (match) => {\n        const isMatch = methodTitleRe.test(match)\n        if (isMatch) {\n          return matches.shift()\n        }\n        return ''\n      })\n    const rre = new RegExp(`(?:${re.source})|(?:${methodTitleRe.source})`, 'g')\n    while ((res = rre.exec(b)) !== null) {\n      let t\n      let level\n      let link\n      if (res[1]) { // normal title regex\n        const [, { length }, title] = res\n        level = length\n        if (this.skipLevelOne && level == 1) continue\n        t = title\n        link = getLink(title)\n      } else { // the method title regex\n        try {\n          const l = res[3]\n          level = l.length\n          const b = res.slice(4, 6).filter(a => a).join(' ').trim()\n          const json = res[7] || '[]'\n          const args = JSON.parse(json)\n          const s = args.map(([name, type]) => {\n            if (typeof type == 'string') return `${name}: ${type}`\n            return `${name}: object`\n          })\n          const fullTitle = replaceTitle(...res.slice(3)).replace(/^#+ +/, '')\n          link = getLink(fullTitle)\n          t = `\\`${b}(${s.join(', ')})${res[6] ? `: ${res[6]}` : ''}\\``\n        } catch (err) {\n          // ok\n          continue\n        }\n      }\n      const heading = `[${t}](#${link})`\n      let s\n      if (level == 2) {\n        s = `- ${heading}`\n      } else {\n        const p = '  '.repeat(level - 2)\n        s = `${p}* ${heading}`\n      }\n      this.push(s)\n      this.push('\\n')\n    }\n    re.lastIndex = -1\n    next()\n  }\n}\n\nexport const getToc = async (stream) => {\n  const rs = new Toc()\n  stream.pipe(rs)\n  const { promise } = new Catchment({ rs })\n  const t = await promise\n  return t.trim()\n}\n\n/**\n * @typedef {Object} Config\n * @property {boolean} [skipLevelOne=true] Don't use the first title in the TOC (default `true`).\n */\n"],"file":"Toc.js"}