{"version":3,"sources":["../../../src/lib/typedef/Type.js"],"names":["Type","fromXML","content","name","type","desc","noToc","spread","Error","description","trim","ps","props","map","c","p","pr","Property","properties","toTypedef","t","d","s","sp","toProp","st","join","toParam","paramName","optional","nn","getSpread","pn","toMarkdown","allTypes","n","line","table","makePropsTable","res","j","length","h","prop","link","getLinkToType","typeWithLink","hasDefault","default","JSON","stringify","linkedType","find","undefined"],"mappings":"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","sourcesContent":["import extractTags from 'rexml'\nimport Property from './Property'\nimport { getLink } from '..'\n\nclass Type {\n  fromXML(content, { name, type, desc, noToc, spread }) {\n    if (!name) throw new Error('Type does not have a name.')\n    this.name = name\n\n    if (type) this.type = type\n    if (desc) this.description = desc.trim()\n    if (noToc) this.noToc = true\n    if (spread) this.spread = true\n\n    if (content) {\n      const ps = extractTags('prop', content)\n      const props = ps.map(({ content: c, props: p }) => {\n        const pr = new Property()\n        pr.fromXML(c, p)\n        return pr\n      })\n      this.properties = props\n    }\n  }\n  toTypedef() {\n    const t = this.type || 'Object'\n    // ${pd ? ` ${pd}` : ''}\n    const d = this.description ? ` ${this.description}` : ''\n    const s = ` * @typedef {${t}} ${this.name}${d}`\n    const p = this.properties ? this.properties.map((pr) => {\n      const sp = pr.toProp()\n      return sp\n    }) : []\n    const st = [s, ...p].join('\\n')\n    return st\n  }\n  toParam(paramName, optional) {\n    const d = this.description ? ` ${this.description}` : ''\n    const nn = this.spread ? getSpread(this.properties) : this.name\n    const pn = optional ? `[${paramName}]` : paramName\n    const s = ` * @param {${nn}} ${pn}${d}`\n    const p = this.properties ? this.properties.map((pr) => {\n      const sp = pr.toParam(paramName)\n      return sp\n    }) : []\n    const st = [s, ...p].join('\\n')\n    return st\n  }\n  toMarkdown(allTypes = []) {\n    const t = this.type ? `\\`${this.type}\\` ` : ''\n    const n = `\\`${this.name}\\``\n    const nn = this.noToc ? n : `[${n}](t)`\n    const d = this.description ? `: ${this.description}` : ''\n    const line = `${t}__${nn}__${d}`\n    const table = makePropsTable(this.properties, allTypes)\n    const res = `${line}${table}`\n    return res\n  }\n}\n\n/**\n * @param {Property[]} properties\n */\nconst getSpread = (properties = []) => {\n  const s = properties.map(p => {\n    const n = p.optional ? `${p.name}?` : p.name\n    const t = p.type\n    const st = `${n}: ${t}`\n    return st\n  })\n  const j = s.join(', ')\n  const st = `{ ${j} }`\n  return st\n}\n\n/**\n * @param {Property[]} props\n * @param {*} allTypes\n */\nconst makePropsTable = (props = [], allTypes = []) => {\n  if (!props.length) return ''\n\n  const h = ['Name', 'Type', 'Description', 'Default']\n  const ps = props.map((prop) => {\n    const link = getLinkToType(allTypes, prop.type)\n    const t = `_${prop.type}_`\n    const typeWithLink = link ? `[${t}](#${link})` : t\n    const name = prop.optional ? prop.name : `__${prop.name}*__`\n    const d = !prop.hasDefault ? '-' : `\\`${prop.default}\\``\n    return [name, typeWithLink, prop.description, d]\n  })\n  const res = [h, ...ps]\n  const j = JSON.stringify(res)\n  return `\n\n\\`\\`\\`table\n${j}\n\\`\\`\\``\n}\n\nconst getLinkToType = (allTypes, type) => {\n  const linkedType = allTypes.find(({ name }) => name == type)\n  const link = linkedType ? getLink(linkedType.name) : undefined\n  return link\n}\n\nexport default Type"],"file":"Type.js"}