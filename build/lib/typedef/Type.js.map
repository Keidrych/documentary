{"version":3,"sources":["../../../src/lib/typedef/Type.js"],"names":["Type","fromXML","content","name","type","desc","noToc","spread","Error","description","trim","ps","props","map","c","p","pr","Property","properties","toTypedef","t","d","s","sp","toProp","st","join","toParam","paramName","nn","getSpread","toMarkdown","allTypes","n","line","table","makePropsTable","res","optional","j","length","h","prop","link","getLinkToType","typeWithLink","hasDefault","default","JSON","stringify","linkedType","find","undefined"],"mappings":"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","sourcesContent":["import extractTags from 'rexml'\nimport Property from './Property'\nimport { getLink } from '..'\n\nclass Type {\n  fromXML(content, { name, type, desc, noToc, spread }) {\n    if (!name) throw new Error('Type does not have a name.')\n    this.name = name\n\n    if (type) this.type = type\n    if (desc) this.description = desc.trim()\n    if (noToc) this.noToc = true\n    if (spread) this.spread = true\n\n    if (content) {\n      const ps = extractTags('prop', content)\n      const props = ps.map(({ content: c, props: p }) => {\n        const pr = new Property()\n        pr.fromXML(c, p)\n        return pr\n      })\n      this.properties = props\n    }\n  }\n  toTypedef() {\n    const t = this.type || 'Object'\n    // ${pd ? ` ${pd}` : ''}\n    const d = this.description ? ` ${this.description}` : ''\n    const s = ` * @typedef {${t}} ${this.name}${d}`\n    const p = this.properties ? this.properties.map((pr) => {\n      const sp = pr.toProp()\n      return sp\n    }) : []\n    const st = [s, ...p].join('\\n')\n    return st\n  }\n  toParam(paramName) {\n    const d = this.description ? ` ${this.description}` : ''\n    const nn = this.spread ? getSpread(this.properties) : this.name\n    const s = ` * @param {${nn}} ${paramName}${d}`\n    const p = this.properties ? this.properties.map((pr) => {\n      const sp = pr.toParam(paramName)\n      return sp\n    }) : []\n    const st = [s, ...p].join('\\n')\n    return st\n  }\n  toMarkdown(allTypes = []) {\n    const t = this.type ? `\\`${this.type}\\` ` : ''\n    const n = `\\`${this.name}\\``\n    const nn = this.noToc ? n : `[${n}](t)`\n    const d = this.description ? `: ${this.description}` : ''\n    const line = `${t}__${nn}__${d}`\n    const table = makePropsTable(this.properties, allTypes)\n    const res = `${line}${table}`\n    return res\n  }\n}\n\n/**\n * @param {Property[]} properties\n */\nconst getSpread = (properties = []) => {\n  const s = properties.map(p => {\n    const n = p.optional ? `${p.name}?` : p.name\n    const t = p.type\n    const st = `${n}: ${t}`\n    return st\n  })\n  const j = s.join(', ')\n  const st = `{ ${j} }`\n  return st\n}\n\n/**\n * @param {Property[]} props\n * @param {*} allTypes\n */\nconst makePropsTable = (props = [], allTypes = []) => {\n  if (!props.length) return ''\n\n  const h = ['Name', 'Type', 'Description', 'Default']\n  const ps = props.map((prop) => {\n    const link = getLinkToType(allTypes, prop.type)\n    const t = `_${prop.type}_`\n    const typeWithLink = link ? `[${t}](#${link})` : t\n    const name = prop.optional ? prop.name : `__${prop.name}*__`\n    const d = !prop.hasDefault ? '-' : `\\`${prop.default}\\``\n    return [name, typeWithLink, prop.description, d]\n  })\n  const res = [h, ...ps]\n  const j = JSON.stringify(res)\n  return `\n\n\\`\\`\\`table\n${j}\n\\`\\`\\``\n}\n\nconst getLinkToType = (allTypes, type) => {\n  const linkedType = allTypes.find(({ name }) => name == type)\n  const link = linkedType ? getLink(linkedType.name) : undefined\n  return link\n}\n\nexport default Type"],"file":"Type.js"}