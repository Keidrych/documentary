{
"version":3,
"file":"stdlib.js",
"lineCount":347,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/mismatch/src/index.js","node_modules/rexml/src/lib/res-simple.js","node_modules/rexml/src/index.js","node_modules/rexml/src/lib/index.js","node_modules/argufy/src/index.js","node_modules/erte/src/diff.js","node_modules/erte/src/index.js","node_modules/makepromise/src/index.js","src/stdlib.js","node_modules/@wrote/read/src/index.js","node_modules/@wrote/write/src/index.js","node_modules/clearr/src/index.js","node_modules/forkfeed/src/index.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","const nameRe = /([^\\s>=/]+)/\nconst valRe = /(?:\"([\\s\\S]*?)\"|'([\\s\\S]*?)')/\n\nexport const attributeRe = new RegExp(`${nameRe.source}(?:\\\\s*=\\\\s*${valRe.source})?`, 'g')\n\n/**\n * This regex will match all attributes as a string inside of element, e.g., matching `<el attr=\"abc\" bool/>` will result in `attr=\"abc\" bool`.\n */\nexport const attributesRe = new RegExp(`\\\\s*((?:${attributeRe.source}\\\\s*)*)`)\n","import mismatch from 'mismatch'\nimport { extractProps as extractPropsSpec, getPropValue } from './lib'\nimport { attributesRe } from './lib/res'\nimport { attributesRe as simple, attributeRe as simpleAttribute } from './lib/res-simple'\n\nconst execRes = (re, s) => {\n  const res = re.exec(s)\n  if (!res) return res\n  const [, ...args] = res\n  return args\n}\n\n/**\n * Extract member elements from an XML string. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nconst extractTags = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${simple.source}?(?:${end1.source}|${end2.source})`, 'g')\n\n  const matches = mismatch(re, string, ['a', 'v', 'v1', 'v2', 'c'])\n  const res = matches.map(({ 'a': attributes = '', 'c': content = '' }) => {\n    const attrs = attributes.replace(/\\/$/, '').trim()\n    const props = extractProps(attrs)\n    return { content, props }\n  })\n  return res\n}\n\n/**\n * Extracts the properties from the attributes part of the tag and returns them as an object. It will parse values if not specified otherwise.\n * @param {string} string The attribute part of the tag.\n * @param {boolean} parseValue Whether to transform the value into its value.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const m = mismatch(simpleAttribute, string, ['key', 'val', 'def', 'f'])\n  const props = m\n    .reduce((acc, { 'key': key, 'val': val }) => {\n      if (val === undefined) {\n        acc[key] = true\n        return acc\n      }\n      acc[key] = parseValue ? getPropValue(val) : val\n      return acc\n    }, {})\n  return props\n}\n\n/**\n * Extract member elements from an XML string using the complex regular expression to match attributes that confirms to the XML spec. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nexport const extractTagsSpec = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${attributesRe.source}?(?:${end1.source}|${end2.source})`, 'gu')\n  const r = []\n\n  let t\n  while ((t = execRes(re, string))) {\n    if (!t.length) continue\n    const [_p = '', _c = ''] = t\n    const p = _p.replace(/\\/$/, '').trim()\n    const props = extractProps(p)\n    const item = {\n      props,\n      content: _c,\n    }\n    r.push(item)\n  }\n  return r\n}\n\nexport default extractTags\nexport { extractPropsSpec }","import { attributeRe } from './res'\n\nexport const getPropValue = (val) => {\n  if (val == 'true') return true\n  if (val == 'false') return false\n  if (/^\\d+$/.test(val)) {\n    return parseInt(val, 10)\n  }\n  return val\n}\n\n/**\n * Parse the arguments part of an XML element\n * @param {string} string String to extract attributes from.\n * @param {boolean} parseValue Parse `true` and `false` values into a boolean, and numbers into integers. Default `true`.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const o = {}\n  const re = new RegExp(`\\\\s+${attributeRe.source}`, 'gu')\n  ;` ${string}`.replace(re, (match, name,  doubleQuoteVal, singleQuoteVal) => {\n    const value = singleQuoteVal || doubleQuoteVal\n    const v = value === undefined ? true : value\n    const val = parseValue ? getPropValue(v) : v\n    o[name] = val\n  })\n  return o\n}\n","/**\n * @param {Array<string>} argv\n * @param {string} long\n * @param {string} [short]\n * @param {boolean} [bool]\n * @param {boolean} [number]\n */\nconst find = (argv, long, short, bool = false, number = false) => {\n  const re = short ? new RegExp(`^-(${short}|-${long})`)\n    : new RegExp(`^--${long}`)\n  const i = argv.findIndex(a => re.test(a))\n  if (i == -1) return { argv }\n\n  if (bool) {\n    return {\n      value: true,\n      argv: [\n        ...argv.slice(0, i),\n        ...argv.slice(i + 1),\n      ],\n    }\n  }\n\n  const j = i + 1\n  let value = argv[j]\n\n  if (!value || (typeof value == 'string' && value.startsWith('--'))) return { argv }\n\n  if (number) {\n    value = parseInt(value, 10)\n  }\n  return {\n    value,\n    argv: [\n      ...argv.slice(0, i),\n      ...argv.slice(j + 1),\n    ],\n  }\n}\n\n/**\n * Parse the config and extract arguments from the `process.argv` array.\n * @param {!_argufy.Config} config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n *\n * - __short__ Shorthand for this argument, usually one letter.\n * - __boolean__ Does not have to be followed by a value, true if given.\n * - __number__ Parse as a number.\n * - __command__ Whether this argument can be specified as the first argument without the dash, such as `example run`.\n * - __multiple__ Extract multiple commands as an  array when `command` is set to true.\n *\n * @example\n```\nconst config = {\n  title: 't',       // program -t Title\n  open: {           // program -o\n    short: 'o',\n    boolean: true,\n  },\n  delay: {          // program -d 100\n    short: 'd',\n    number: true,\n  },\n  file: {           // program File.txt\n    command: true,\n  },\n  file2: {           // program File.txt File2.txt\n    command: true,\n    multiple: true,\n  },\n}\n```\n * @param {!Array<string>} [args] Array with arguments to parse. `process.argv` is used by default. It is assumed that user arguments start from the 3rd position.\n * @returns {Object<string, string|Array<string>|boolean|number>} An object with all found values for the configuration request.\n */\nexport default function argufy(config = {}, args = process.argv) {\n  let [, , ...argv] = args\n  const titles = findTitles(argv)\n  argv = argv.slice(titles.length)\n  let commandFound = !titles.length\n  const res = Object.keys(config).reduce(({ _argv, ...acc }, key) => {\n    if (_argv.length == 0 && commandFound) return { _argv, ...acc }\n    const val = config[key]\n    let value\n    if (typeof val == 'string') {\n      ({ value, argv: _argv } = find(_argv, key, val))\n    } else {\n      try {\n        const { short, boolean, number, command, multiple } = val\n        if (command && multiple && titles.length) {\n          value = titles\n          commandFound = true\n        } else if (command && titles.length) {\n          value = titles[0]\n          commandFound = true\n        } else {\n          ({ value, argv: _argv } = find(_argv, key, short, boolean, number))\n        }\n      } catch (err) {\n        return { _argv, ...acc }\n      }\n    }\n    if (value === undefined) return { _argv, ...acc }\n    const r = { _argv, ...acc, [key]: value }\n    return r\n  }, {\n    _argv: argv,\n  })\n  return res\n}\n\n/** @param {!Array<string>} argv */\nconst findTitles = argv => {\n  const titles = []\n  for (let i = 0; i < argv.length; i++) {\n    const a = argv[i]\n    if (a.startsWith('-')) break\n    titles.push(a)\n  }\n  return titles\n}\n\n/**\n * Based on the argufy config, creates an object that can be passed to `usually`.\n * @param {!_argufy.Config} argsConfig The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n * @example\n```\n{ 'input': 'The input to the program',\n  '--output, -o': 'The output of the program', }\n```\n */\nexport const reduceUsage = (argsConfig) => {\n  const a = Object.keys(argsConfig).reduce((acc, key) => {\n    const val = argsConfig[key]\n    if (typeof val == 'string') {\n      const k = `-${val}`\n      acc[k] = ''\n      return acc\n    }\n    let k = val.command ? key : `--${key}`\n    if (val.short) k = `${k}, -${val.short}`\n    let d = val.description\n    if (val.default) d = `${d}\\nDefault: ${val.default}.`\n    acc[k] = d\n    return acc\n  }, {})\n  return a\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Config} Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, string|!_argufy.Flag>} _argufy.Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Flag} Flag The flag passed to the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _argufy.Flag The flag passed to the program.\n * @prop {string} [short] Shorthand for this argument, usually one letter.\n * @prop {boolean} [boolean=false] Whether the flag is a boolean and does not require a value. Default `false`.\n * @prop {boolean} [number=false] Specifies whether the flag should be parsed as a number. Default `false`.\n * @prop {boolean} [command=false] If set to true, the value is read from the first argument passed to the CLI command (e.g., `$ cli command`). Default `false`.\n * @prop {boolean} [multiple=false] When using the `command` property, will parse the commands as an array. Default `false`.\n * @prop {string} [default] The default value for the argument. Does not actually set the value, only used in reducing the usage info (`argufy` bin on the other hand will set the default).\n * @prop {string} [description] The description to be used by `usually`.\n */\n","/**\n * @license diff package https://github.com/kpdecker/jsdiff\n * BSD License\n * Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n */\nexport default class Diff {\n  diff(oldString, newString) {\n    let self = this\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString)\n    newString = this.castInput(newString)\n\n    oldString = this.removeEmpty(this.tokenize(oldString))\n    newString = this.removeEmpty(this.tokenize(newString))\n\n    let newLen = newString.length, oldLen = oldString.length\n    let editLength = 1\n    let maxEditLength = newLen + oldLen\n    let bestPath = [{ newPos: -1, components: [] }]\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return [{ value: this.join(newString), count: newString.length }]\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath\n        let addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          oldPos = (removePath ? removePath.newPos : 0) - diagonalPath\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= oldPos && oldPos < oldLen\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined\n          continue\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath)\n          self.pushComponent(basePath.components, undefined, true)\n        } else {\n          basePath = addPath // No need to clone, we've pulled it from the list\n          basePath.newPos++\n          self.pushComponent(basePath.components, true, undefined)\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newString, oldString)\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath\n        }\n      }\n\n      editLength++\n    }\n\n    while (editLength <= maxEditLength) {\n      let ret = execEditLength()\n      if (ret) {\n        return ret\n      }\n    }\n  }\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1]\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }\n    } else {\n      components.push({ count: 1, added: added, removed: removed })\n    }\n  }\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n\n      commonCount = 0\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++\n      oldPos++\n      commonCount++\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount })\n    }\n\n    basePath.newPos = newPos\n    return oldPos\n  }\n\n  equals(left, right) {\n    return left === right\n  }\n  removeEmpty(array) {\n    let ret = []\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i])\n      }\n    }\n    return ret\n  }\n  castInput(value) {\n    return value\n  }\n  tokenize(value) {\n    return value.split('')\n  }\n  join(chars) {\n    return chars.join('')\n  }\n}\n\nfunction buildValues(diff, components, newString, oldString) {\n  let componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos]\n    if (!component.removed) {\n      if (!component.added) {\n        let value = newString.slice(newPos, newPos + component.count)\n        value = value.map(function(v, i) {\n          let oldValue = oldString[oldPos + i]\n          return oldValue.length > v.length ? oldValue : v\n        })\n\n        component.value = diff.join(value)\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count))\n      }\n      newPos += component.count\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))\n      oldPos += component.count\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1]\n        components[componentPos - 1] = components[componentPos]\n        components[componentPos] = tmp\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1]\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value\n    components.pop()\n  }\n\n  return components\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) }\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import write from '@wrote/write'\nimport read from '@wrote/read'\nimport rexml from 'rexml'\nimport argufy, { reduceUsage } from 'argufy'\nimport Catchment, { collect } from 'catchment'\nimport clearr from 'clearr'\n// import competent from 'competent'\nimport erte, { c, b } from 'erte'\nimport forkfeed from 'forkfeed'\nimport makepromise from 'makepromise'\nimport mismatch from 'mismatch'\n\nmodule.exports = {\n  'c': c,\n  'b': b,\n  'read': read,\n  'rexml': rexml,\n  'reduceUsage': reduceUsage,\n  'write': write,\n  'argufy': argufy,\n  'Catchment': Catchment,\n  'collect': collect,\n  'clearr': clearr,\n  // 'competent': competent,\n  'erte': erte,\n  'forkfeed': forkfeed,\n  'makepromise': makepromise,\n  'mismatch': mismatch,\n}","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","/**\n * Clears the carriage return like the terminal would.\n * @param {string} string The string with the `\\r`.\n * @example\n * const res = clearR('...\\r..?\\r.!')\n * // output: .!?\n */\nconst clearR = (string) => {\n  const st = string.split('\\n').map(l => {\n    const r = l.split('\\r')\n    const t = r.reduce((acc, current, i) => {\n      if (!i) return acc\n      const { length } = current\n      const after = acc.slice(length)\n      return `${current}${after}`\n    }, r[0])\n    return t\n  }).join('\\n')\n  return st\n}\n\nexport default clearR","/**\n * Write data to the `writable` when data from the `readable` matches the regexp.\n * @param {!stream.Readable} readable A readable stream to detect data on.\n * @param {!stream.Writable} stdin A writable stream to pass answers to.\n * @param {!Array<!Array<(!RegExp|string)>>} inputs A serial collection of answers. Each answer will be ended with a `\\n` character. For example, `[[/question/, 'answer'], [/question2/, 'answer2]]`.\n * @param {stream.Writable} [log] A stream to which to write both data from readable, and the passed answer.\n */\nconst forkFeed = (readable, stdin, inputs = [], log = null) => {\n  if (log) readable.on('data', d => log.write(d))\n\n  let [a, ...rest] = inputs\n  if (!a) return\n\n  const handler = (d) => {\n    const [regexp, answer] = a\n    if (!regexp.test(d)) return\n\n    const an = `${answer}\\n`\n    if (log) log.write(an)\n\n    stdin.write(an)\n    ;([a, ...rest] = rest)\n    if (!a) readable.removeListener('data', handler)\n  }\n  readable.on('data', handler)\n}\n\nexport default forkFeed\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Writable} stream.Writable\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n"],
"names":["createReadStream","createWriteStream","fs","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","re","RegExp","source","replace","j","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","Writable","stream","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","mismatch","string","keys","addPositions","position","start","o","p","reduce","acc","capturedGroup","i","key","attributeRe","nameRe","valRe","attributesRe","extractProps","simpleAttribute","props","val","parseInt","find","argv","long","short","bool","number","findIndex","a","value","startsWith","findTitles","titles","pushComponent","components","added","removed","last","count","extractCommon","basePath","newString","oldString","diagonalPath","newLen","oldLen","newPos","oldPos","commonCount","equals","removeEmpty","array","ret","diff","Diff","editLength","maxEditLength","bestPath","addPath","removePath","canAdd","canRemove","self","buildValues","left","right","chars","componentPos","componentLen","component","tmp","v","oldValue","lastComponent","pop","colors","backgroundColors","c","color","cc","b","checkArgumentIndex","module","exports","read","path","tag","extractTags","matches","simple","end1","end2","attributes","content","attrs","argsConfig","reduceUsage","k","command","description","default","write","data","ws","err","end","argufy","config","process","commandFound","_argv","boolean","multiple","clearR","l","t","current","after","st","erte","target","s","stdin","inputs","log","forkFeed","rest","handler","regexp","answer","an","removeListener","makePromise","fn","resolveValue","fnLength","resolve","reject","error","allArgs","Array","isArray","forEach","arg"]
}
