{
"version":3,
"file":"stdlib.js",
"lineCount":672,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/makepromise/src/index.js","node_modules/path/index.js","node_modules/@wrote/ensure-path/src/index.js","node_modules/@wrote/read-dir-structure/src/index.js","node_modules/@wrote/clone/src/index.js","node_modules/mismatch/src/index.js","node_modules/rexml/src/lib/res-simple.js","node_modules/rexml/src/index.js","node_modules/rexml/src/lib/index.js","node_modules/argufy/src/index.js","node_modules/erte/src/diff.js","node_modules/erte/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/resolve-dependency/src/index.js","node_modules/child_process/index.js","node_modules/spawncommand/src/index.js","node_modules/restream/src/lib/index.js","node_modules/restream/src/SyncReplaceable.js","node_modules/restream/src/lib/markers.js","node_modules/restream/src/Replaceable.js","src/stdlib.js","node_modules/@wrote/read/src/index.js","node_modules/usually/src/index.js","node_modules/@wrote/write/src/index.js","node_modules/clearr/src/index.js","node_modules/forkfeed/src/index.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import { mkdir, mkdirSync } from 'fs'\nimport makePromise from 'makepromise'\nimport { dirname } from 'path'\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport default async function ensurePath(path) {\n  const dir = dirname(path)\n  try {\n    await make(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nasync function make(dir) {\n  try {\n    await makePromise(mkdir, dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      await make(parentDir)\n      await make(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to synchronously, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport function ensurePathSync(path) {\n  const dir = dirname(path)\n  try {\n    makeSync(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nfunction makeSync(dir) {\n  try {\n    mkdirSync(dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      makeSync(parentDir)\n      makeSync(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}","import { lstat, readdir } from 'fs'\nimport makePromise from 'makepromise'\nimport { join } from 'path'\n\n/**\n * Update information about directory's content with lstat.\n * @param {string} dirPath Path to the root directory\n * @param {!Array<string>} dirContent\n * @returns {Promise<Array<_readDirStructure.File>>} An array with file objects.\n */\nasync function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}\n\n/**\n * Check if lstat result is a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is a directory\n */\nconst isDirectory = lstatRes => lstatRes.lstat.isDirectory()\n/**\n * Check if lstat result is not a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is not a directory\n */\nconst isNotDirectory = lstatRes => !lstatRes.lstat.isDirectory()\n\nconst getType = (lstatRes) => {\n  if (lstatRes.lstat.isDirectory()) {\n    return 'Directory'\n  }\n  if (lstatRes.lstat.isFile()) {\n    return 'File'\n  }\n  if (lstatRes.lstat.isSymbolicLink()) {\n    return 'SymbolicLink'\n  }\n}\n\n/**\n * Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n * @param {string} dirPath Path to the directory.\n * @returns {Promise<_readDirStructure.DirectoryStructure>} An object reflecting the directory structure.\n * @example\n```js\nconst res = await readDirStructure('dir')\n// result:\n{\n  type: 'Directory',\n  content: {\n    'data.txt': {\n      type: 'File'\n    },\n    subdir: {\n      type: 'Directory',\n      content: {\n        'data-ln.txt': {\n          type: 'SymbolicLink'\n        },\n      }\n    }\n  }\n}\n```\n */\nexport default async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}\n\n/**\n * After running the `readDirStructure`, this function can be used to flatten the `content` output and return the list of all files (not including symlinks).\n * @param {!_readDirStructure.Content} content The recursive content of the directory.\n * @param {string} path The path to the directory.\n */\nexport const getFiles = (content, path) => {\n  let files = []\n  let dirs = []\n  Object.keys(content).forEach((key) => {\n    const { type } = content[key]\n    if (type == 'File') files.push(join(path, key))\n    else if (type == 'Directory') dirs.push(key)\n  })\n  const dirFiles = dirs.reduce((acc, dir) => {\n    const { content: c } =\n      /** @type {!_readDirStructure.Content} */ (content[dir])\n    const f = getFiles(c, join(path, dir))\n    return [...acc, ...f]\n  }, [])\n  return [...files, ...dirFiles]\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.File} File\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.File\n * @prop {!fs.Stats} lstat The stats of the item.\n * @prop {string} path The full path of the item.\n * @prop {string} relativePath The name of the item.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.Content} Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, !_readDirStructure.DirectoryStructure>} _readDirStructure.Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.DirectoryStructure} DirectoryStructure A directory structure representation.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.DirectoryStructure A directory structure representation.\n * @prop {string} [type] The type of the item.\n * @prop {!_readDirStructure.Content} [content] The recursive content if the item is a directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */\n","import ensurePath from '@wrote/ensure-path'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport makePromise from 'makepromise'\nimport {\n  createReadStream, createWriteStream, lstat, readlink, symlink,\n} from 'fs'\nimport { join, basename } from 'path'\n\n/**\n * Clone a file.\n * @param {string} from Path to the file which to clone.\n * @param {string} to Path to the file where to clone.\n */\nconst cloneFile = async (from, to) => {\n  const rs = createReadStream(from)\n  const ws = createWriteStream(to)\n  rs.pipe(ws)\n  await Promise.all([\n    new Promise((r, j) => {\n      rs.on('close', r).on('error', j)\n    }),\n    new Promise((r, j) => {\n      ws.on('close', r).on('error', j)\n    }),\n  ])\n}\n\nconst cloneLn = async (from, to) => {\n  const target = await makePromise(readlink, from)\n  await makePromise(symlink, [target, to])\n}\n\n/**\n * Clones a directory.\n * @param {string} from Path of the file or directory being cloned.\n * @param {string} to Path to the cloned directory (not its parent!).\n */\nconst cloneDir = async (from, to) => {\n  await ensurePath(join(to, 'path.file'))\n  const { content } = await readDirStructure(from)\n  const pr = Object.keys(/** @type {!Object} */ (content)).map(async (k) => {\n    const { type } = content[k]\n    const p = join(from, k)\n    const pt = join(to, k)\n    if (type == 'Directory') {\n      await cloneDir(p, pt)\n    } else if (type == 'File') {\n      await cloneFile(p, pt)\n    } else if (type == 'SymbolicLink') {\n      await cloneLn(p, pt)\n    }\n  })\n  await Promise.all(pr)\n}\n\n/**\n * Clone a file or directory.\n * @param {string} path Path to the file or directory to clone.\n * @param {string} to Path to the directory to contain the file or directory being cloned (not the path to the cloned entity).\n */\nconst clone = async (path, to) => {\n  const s = /** @type {!fs.Stats} */ (await makePromise(lstat, path))\n  const b = basename(path)\n  const t = join(to, b)\n\n  if (s.isDirectory()) {\n    await cloneDir(path, t)\n  } else if (s.isSymbolicLink()) {\n    await cloneLn(path, t)\n  } else {\n    await ensurePath(t)\n    await cloneFile(path, t)\n  }\n}\n\nexport default clone\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","const nameRe = /([^\\s>=/]+)/\nconst valRe = /(?:\"([\\s\\S]*?)\"|'([\\s\\S]*?)')/\n\nexport const attributeRe = new RegExp(`${nameRe.source}(?:\\\\s*=\\\\s*${valRe.source})?`, 'g')\n\n/**\n * This regex will match all attributes as a string inside of element, e.g., matching `<el attr=\"abc\" bool/>` will result in `attr=\"abc\" bool`.\n */\nexport const attributesRe = new RegExp(`\\\\s*((?:${attributeRe.source}\\\\s*)*)`)\n","import mismatch from 'mismatch'\nimport { extractProps as extractPropsSpec, getPropValue } from './lib'\nimport { attributesRe } from './lib/res'\nimport { attributesRe as simple, attributeRe as simpleAttribute } from './lib/res-simple'\n\nconst execRes = (re, s) => {\n  const res = re.exec(s)\n  if (!res) return res\n  const [, ...args] = res\n  return args\n}\n\n/**\n * Extract member elements from an XML string. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nconst extractTags = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${simple.source}?(?:${end1.source}|${end2.source})`, 'g')\n\n  const matches = mismatch(re, string, ['a', 'v', 'v1', 'v2', 'c'])\n  const res = matches.map(({ 'a': attributes = '', 'c': content = '' }) => {\n    const attrs = attributes.replace(/\\/$/, '').trim()\n    const props = extractProps(attrs)\n    return { content, props }\n  })\n  return res\n}\n\n/**\n * Extracts the properties from the attributes part of the tag and returns them as an object. It will parse values if not specified otherwise.\n * @param {string} string The attribute part of the tag.\n * @param {boolean} parseValue Whether to transform the value into its value.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const m = mismatch(simpleAttribute, string, ['key', 'val', 'def', 'f'])\n  const props = m\n    .reduce((acc, { 'key': key, 'val': val }) => {\n      if (val === undefined) {\n        acc[key] = true\n        return acc\n      }\n      acc[key] = parseValue ? getPropValue(val) : val\n      return acc\n    }, {})\n  return props\n}\n\n/**\n * Extract member elements from an XML string using the complex regular expression to match attributes that confirms to the XML spec. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nexport const extractTagsSpec = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${attributesRe.source}?(?:${end1.source}|${end2.source})`, 'gu')\n  const r = []\n\n  let t\n  while ((t = execRes(re, string))) {\n    if (!t.length) continue\n    const [_p = '', _c = ''] = t\n    const p = _p.replace(/\\/$/, '').trim()\n    const props = extractProps(p)\n    const item = {\n      props,\n      content: _c,\n    }\n    r.push(item)\n  }\n  return r\n}\n\nexport default extractTags\nexport { extractPropsSpec }","import { attributeRe } from './res'\n\nexport const getPropValue = (val) => {\n  if (val == 'true') return true\n  if (val == 'false') return false\n  if (/^\\d+$/.test(val)) {\n    return parseInt(val, 10)\n  }\n  return val\n}\n\n/**\n * Parse the arguments part of an XML element\n * @param {string} string String to extract attributes from.\n * @param {boolean} parseValue Parse `true` and `false` values into a boolean, and numbers into integers. Default `true`.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const o = {}\n  const re = new RegExp(`\\\\s+${attributeRe.source}`, 'gu')\n  ;` ${string}`.replace(re, (match, name,  doubleQuoteVal, singleQuoteVal) => {\n    const value = singleQuoteVal || doubleQuoteVal\n    const v = value === undefined ? true : value\n    const val = parseValue ? getPropValue(v) : v\n    o[name] = val\n  })\n  return o\n}\n","/**\n * @param {Array<string>} argv\n * @param {string} long\n * @param {string} [short]\n * @param {boolean} [bool]\n * @param {boolean} [number]\n */\nconst find = (argv, long, short, bool = false, number = false) => {\n  const re = short ? new RegExp(`^-(${short}|-${long})`)\n    : new RegExp(`^--${long}`)\n  const i = argv.findIndex(a => re.test(a))\n  if (i == -1) return { argv }\n\n  if (bool) {\n    return {\n      value: true,\n      argv: [\n        ...argv.slice(0, i),\n        ...argv.slice(i + 1),\n      ],\n    }\n  }\n\n  const j = i + 1\n  let value = argv[j]\n\n  if (!value || (typeof value == 'string' && value.startsWith('--'))) return { argv }\n\n  if (number) {\n    value = parseInt(value, 10)\n  }\n  return {\n    value,\n    argv: [\n      ...argv.slice(0, i),\n      ...argv.slice(j + 1),\n    ],\n  }\n}\n\n/**\n * Parse the config and extract arguments from the `process.argv` array.\n * @param {!_argufy.Config} config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n *\n * - __short__ Shorthand for this argument, usually one letter.\n * - __boolean__ Does not have to be followed by a value, true if given.\n * - __number__ Parse as a number.\n * - __command__ Whether this argument can be specified as the first argument without the dash, such as `example run`.\n * - __multiple__ Extract multiple commands as an  array when `command` is set to true.\n *\n * @example\n```\nconst config = {\n  title: 't',       // program -t Title\n  open: {           // program -o\n    short: 'o',\n    boolean: true,\n  },\n  delay: {          // program -d 100\n    short: 'd',\n    number: true,\n  },\n  file: {           // program File.txt\n    command: true,\n  },\n  file2: {           // program File.txt File2.txt\n    command: true,\n    multiple: true,\n  },\n}\n```\n * @param {!Array<string>} [args] Array with arguments to parse. `process.argv` is used by default. It is assumed that user arguments start from the 3rd position.\n * @returns {Object<string, string|Array<string>|boolean|number>} An object with all found values for the configuration request.\n */\nexport default function argufy(config = {}, args = process.argv) {\n  let [, , ...argv] = args\n  const titles = findTitles(argv)\n  argv = argv.slice(titles.length)\n  let commandFound = !titles.length\n  const res = Object.keys(config).reduce(({ _argv, ...acc }, key) => {\n    if (_argv.length == 0 && commandFound) return { _argv, ...acc }\n    const val = config[key]\n    let value\n    if (typeof val == 'string') {\n      ({ value, argv: _argv } = find(_argv, key, val))\n    } else {\n      try {\n        const { short, boolean, number, command, multiple } = val\n        if (command && multiple && titles.length) {\n          value = titles\n          commandFound = true\n        } else if (command && titles.length) {\n          value = titles[0]\n          commandFound = true\n        } else {\n          ({ value, argv: _argv } = find(_argv, key, short, boolean, number))\n        }\n      } catch (err) {\n        return { _argv, ...acc }\n      }\n    }\n    if (value === undefined) return { _argv, ...acc }\n    const r = { _argv, ...acc, [key]: value }\n    return r\n  }, {\n    _argv: argv,\n  })\n  return res\n}\n\n/** @param {!Array<string>} argv */\nconst findTitles = argv => {\n  const titles = []\n  for (let i = 0; i < argv.length; i++) {\n    const a = argv[i]\n    if (a.startsWith('-')) break\n    titles.push(a)\n  }\n  return titles\n}\n\n/**\n * Based on the argufy config, creates an object that can be passed to `usually`.\n * @param {!_argufy.Config} argsConfig The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n * @example\n```\n{ 'input': 'The input to the program',\n  '--output, -o': 'The output of the program', }\n```\n */\nexport const reduceUsage = (argsConfig) => {\n  const a = Object.keys(argsConfig).reduce((acc, key) => {\n    const val = argsConfig[key]\n    if (typeof val == 'string') {\n      const k = `-${val}`\n      acc[k] = ''\n      return acc\n    }\n    let k = val.command ? key : `--${key}`\n    if (val.short) k = `${k}, -${val.short}`\n    let d = val.description\n    if (val.default) d = `${d}\\nDefault: ${val.default}.`\n    acc[k] = d\n    return acc\n  }, {})\n  return a\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Config} Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, string|!_argufy.Flag>} _argufy.Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Flag} Flag The flag passed to the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _argufy.Flag The flag passed to the program.\n * @prop {string} [short] Shorthand for this argument, usually one letter.\n * @prop {boolean} [boolean=false] Whether the flag is a boolean and does not require a value. Default `false`.\n * @prop {boolean} [number=false] Specifies whether the flag should be parsed as a number. Default `false`.\n * @prop {boolean} [command=false] If set to true, the value is read from the first argument passed to the CLI command (e.g., `$ cli command`). Default `false`.\n * @prop {boolean} [multiple=false] When using the `command` property, will parse the commands as an array. Default `false`.\n * @prop {string} [default] The default value for the argument. Does not actually set the value, only used in reducing the usage info (`argufy` bin on the other hand will set the default).\n * @prop {string} [description] The description to be used by `usually`.\n */\n","/**\n * @license diff package https://github.com/kpdecker/jsdiff\n * BSD License\n * Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n */\nexport default class Diff {\n  diff(oldString, newString) {\n    let self = this\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString)\n    newString = this.castInput(newString)\n\n    oldString = this.removeEmpty(this.tokenize(oldString))\n    newString = this.removeEmpty(this.tokenize(newString))\n\n    let newLen = newString.length, oldLen = oldString.length\n    let editLength = 1\n    let maxEditLength = newLen + oldLen\n    let bestPath = [{ newPos: -1, components: [] }]\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return [{ value: this.join(newString), count: newString.length }]\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath\n        let addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          oldPos = (removePath ? removePath.newPos : 0) - diagonalPath\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= oldPos && oldPos < oldLen\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined\n          continue\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath)\n          self.pushComponent(basePath.components, undefined, true)\n        } else {\n          basePath = addPath // No need to clone, we've pulled it from the list\n          basePath.newPos++\n          self.pushComponent(basePath.components, true, undefined)\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newString, oldString)\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath\n        }\n      }\n\n      editLength++\n    }\n\n    while (editLength <= maxEditLength) {\n      let ret = execEditLength()\n      if (ret) {\n        return ret\n      }\n    }\n  }\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1]\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }\n    } else {\n      components.push({ count: 1, added: added, removed: removed })\n    }\n  }\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n\n      commonCount = 0\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++\n      oldPos++\n      commonCount++\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount })\n    }\n\n    basePath.newPos = newPos\n    return oldPos\n  }\n\n  equals(left, right) {\n    return left === right\n  }\n  removeEmpty(array) {\n    let ret = []\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i])\n      }\n    }\n    return ret\n  }\n  castInput(value) {\n    return value\n  }\n  tokenize(value) {\n    return value.split('')\n  }\n  join(chars) {\n    return chars.join('')\n  }\n}\n\nfunction buildValues(diff, components, newString, oldString) {\n  let componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos]\n    if (!component.removed) {\n      if (!component.added) {\n        let value = newString.slice(newPos, newPos + component.count)\n        value = value.map(function(v, i) {\n          let oldValue = oldString[oldPos + i]\n          return oldValue.length > v.length ? oldValue : v\n        })\n\n        component.value = diff.join(value)\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count))\n      }\n      newPos += component.count\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))\n      oldPos += component.count\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1]\n        components[componentPos - 1] = components[componentPos]\n        components[componentPos] = tmp\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1]\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value\n    components.pop()\n  }\n\n  return components\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) }\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","export default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process","import { spawn, fork as forkCp } from 'child_process'\nimport { collect } from 'catchment'\n\n/**\n * @param {!child_process.ChildProcess} proc\n * @returns {!Promise<_spawncommand.PromiseResult>}\n */\nconst getPromise = async (proc) => {\n  const [code, stdout, stderr] = await Promise.all([\n    new Promise((resolve, reject) => {\n      proc.on('error', reject)\n        .on('exit', (code) => {\n          resolve(code)\n        })\n    }),\n    proc.stdout ? collect(proc.stdout) : undefined,\n    proc.stderr ? collect(proc.stderr) : undefined,\n  ])\n  return {\n    code,\n    stdout,\n    stderr,\n  }\n}\n\n/**\n * Spawns a new process using the `command` and returns an instance of a ChildProcess, extended to have a `promise` property which is resolved when the process exits. The resolved value is an object with `stdout`, `stderr` and `code` properties.\n * @param {string} command The command to run.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.SpawnOptions} [options] Options used to spawn.\n */\nexport default function spawnCommand(command, args, options) {\n  if (!command) throw new Error('Please specify a command to spawn.')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (spawn(command, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/**\n * Forks a process and assign a `promise` property to it, resolved with `stderr`, `stdout` and `code` properties on exit.\n * @param {string} mod The module to run in the child.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.ForkOptions} [options] Options to fork the process with.\n */\nexport function fork(mod, args, options) {\n  if (!mod) throw new Error('Please specify a module to fork')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (forkCp(mod, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.PromiseResult} PromiseResult\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.PromiseResult\n * @prop {string} stdout The accumulated result of the `stdout` stream.\n * @prop {string} stderr The accumulated result of the `stderr` stream.\n * @prop {number} code The code with which the process exited.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').SpawnOptions} child_process.SpawnOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ChildProcess} child_process.ChildProcess\n */\n\n/* documentary types/cp.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.ChildProcessWithPromise} ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {child_process.ChildProcess & _spawncommand.$ChildProcessWithPromise} _spawncommand.ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.$ChildProcessWithPromise A child process with an extra `promise` property.\n * @prop {!Promise<!_spawncommand.PromiseResult>} promise A promise resolved when the process exits.\n * @prop {string} spawnCommand The spawn arguments joined by whitespace.\n */\n","export function checkRule(reObject) {\n  if (typeof reObject != 'object') {\n    return false\n  }\n  const { re, replacement } = reObject\n  const hasRe = re instanceof RegExp\n  const type = ['string', 'function'].indexOf(typeof replacement) != -1\n  return hasRe && type\n}\n\nexport const hideStack = (commonError, thrownError) => {\n  if (!(thrownError instanceof Error)) throw thrownError\n  const [, , commonLine] = commonError.stack.split('\\n', 3)\n  const i = thrownError.stack.indexOf(commonLine)\n  if (i == -1) throw thrownError\n  const stack = thrownError.stack.substr(0, i - 1)\n  const li = stack.lastIndexOf('\\n')\n  thrownError.stack = stack.substr(0, li)\n  throw thrownError\n}","import { checkRule, hideStack } from './lib'\n\n/**\n  * _SyncReplaceable_ function receives the whole string and returns the result of transform rules which are either sync function replacers or string replacements (see https://github.com/artdecocode/restream#rule-type for more info). This is not a class and just a function.\n  * @param {string|!Buffer} input The string or buffer to transform synchronously using the replacements. Does not support asynchronous replacements.\n  * @param {!Array<!_restream.Rule>} rules An array with rules.\n  * @return {string}\n  * @example\n```\n// markdown __ to html <em> implementation\nconst stream = SyncReplaceable('__hello world__', {\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n  */\nfunction SyncReplaceable(input, rules) {\n  /**\n   * @suppress {globalThis}\n   */\n  function replace() {\n    const fr = rules.filter(checkRule)\n    const s = fr.reduce((acc, { re, replacement }) => {\n      /** @type {string} */\n      let Acc = acc\n      if (this._broke) return Acc\n\n      if (typeof replacement == 'string') {\n        Acc = Acc.replace(re, replacement)\n        return Acc\n      } else {\n        let commonError\n        const t = Acc.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) return match\n            const p = replacement.call(this, match, ...args)\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        return t\n      }\n    }, `${input}`)\n    return s\n  }\n  replace.brake = () => { replace._broke = true }\n  return replace.call(replace)\n}\n\nexport default SyncReplaceable\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */","import SyncReplaceable from '../SyncReplaceable'\n\n/**\n * @param {string} name\n */\nconst getDefaultRegExp = (name) => {\n  return new RegExp(`%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%`, 'g')\n}\n\n/**\n * Make a unique string to replace cut text with.\n * @param {string} name\n * @param {number} index\n */\nconst getDefaultReplacement = (name, index) => {\n  return `%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%`\n}\n\n/**\n * Create a new marker.\n * @param {string} name The name of the matcher, used in the doc marker.\n * @param {!RegExp} re The regular expression used for detection.\n * @param {!_restream.MakeMarkersConfig} [conf] Additional configuration.\n * @param {function(string, number): string} [conf.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [conf.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @return {!_restream.Marker} The marker.\n */\nconst makeMarker = (name, re, conf) => {\n  const {\n    getReplacement = getDefaultReplacement,\n    getRegex = getDefaultRegExp,\n  } = conf || {}\n  const regExp = getRegex(name)\n  return {\n    name,\n    re,\n    regExp,\n    getReplacement,\n    map: {},\n    lastIndex: 0,\n  }\n}\n\n/**\n * Make markers from a configuration object.\n * @param {!Object.<string, !RegExp>} matchers An object with types of markers to create as keys and their detection regexes as values.\n * @param {!_restream.MakeMarkersConfig} [config] Additional configuration.\n * @param {function(string, number): string} [config.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [config.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @returns {!Object.<string, !_restream.Marker>} An object with markers for each requested type.\n */\nexport const makeMarkers = (matchers, config) => {\n  const res = Object.keys(matchers).reduce((acc, key) => {\n    const re = matchers[key]\n    const marker = makeMarker(key, re, config)\n    const m = {\n      ...acc,\n      [key]: marker,\n    }\n    return m\n  }, {})\n  return res\n}\n\n/**\n * Make a rule for pasting markers back.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @param {!(_restream.Rule|Array<!_restream.Rule>)} [pipeRules] Any additional rules to replace the value of the marker before pasting it.\n * @returns {!_restream.Rule} A rule to paste previously replaced chunks.\n */\nexport const makePasteRule = (marker, pipeRules = []) => {\n  const { regExp: re, map } = marker\n  const rule = {\n    re,\n    replacement(match, index) {\n      const m = map[index]\n      delete map[index]\n      const pr = Array.isArray(pipeRules) ? pipeRules : [pipeRules]\n      const res = SyncReplaceable(m, pr)\n      return res\n    },\n  }\n  return rule\n}\n\n/**\n * Make a rule for initial replacement of markers.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @returns {!_restream.Rule} A rule to cut matched chunks.\n */\nexport const makeCutRule = (marker) => {\n  const { re, map, getReplacement, name } = marker\n  const rule = {\n    re,\n    replacement(match) {\n      const { lastIndex } = marker\n      map[lastIndex] = match\n      marker.lastIndex += 1\n      const m = getReplacement(name, lastIndex)\n      return m\n    },\n  }\n  return rule\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */\n\n/* documentary types/markers.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.Marker} Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @prop {string} name The name of the marker for annotation purposes.\n * @prop {function(string, number): string} getReplacement The function to generate marker placeholders which can be then found, e.g., for (name: `marker`, index: `10`) by default _Restream_ will generate `%%_RESTREAM_MARKER_REPLACEMENT_10_%%`, but can be overriden with this method.\n * @prop {!RegExp} re The regular expression used for detection of the match.\n * @prop {!RegExp} regExp The generated regular expression to replace the marker back to its original value.\n * @prop {!Object<number, string>} map The map which holds detected matches at their indexes.\n * @prop {number} lastIndex The index of the last inserted element. Starts with 0.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.MakeMarkersConfig} MakeMarkersConfig Additional configuration.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.MakeMarkersConfig Additional configuration.\n * @prop {function(string, number): string} [getReplacement] The function used to create a replacement when some text needs to be cut.\n * @prop {function(string): !RegExp} [getRegex] The function used to create a RegExp to detect replaced chunks.\n */\n","import Stream, { Transform } from 'stream'\nimport cleanStack from '@artdeco/clean-stack'\nimport { collect } from 'catchment'\nimport { checkRule, hideStack } from './lib'\n\nexport default class Replaceable extends Transform {\n  /**\n   * Replaceable class that extends Transform and pushes data when it's done replacing each incoming chunk. If the replacement is passed as a function, it will work in the same way as the replacer for `string.replace` method (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), taking the `match` as the first argument, and matched `p1`, `p2`, _etc_ parameters as following arguments. The replacer can also be an async function.\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules A single replacement rule, or multiple rules.\n   * @param {!stream.TransformOptions} [options] The options for the transform stream.\n   * @example\n   *\n```\n// markdown __ to html <em> implementation\nconst stream = replaceStream({\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n   */\n  constructor(rules, options) {\n    super(options)\n    const re = Array.isArray(rules) ? rules : [rules]\n    const fr = re.filter(checkRule)\n    this.rules = fr\n    /**\n     * Whether the _Replaceable_ will not apply any more rules.\n     * @type {boolean}\n     */\n    this._broke = false\n    this._options = options\n  }\n\n  /**\n   * Creates a new replaceable to replace the given string, buffer or stream using the rules of the current stream. Calling `brake` will also set `_broke` on the parent stream.\n   * @param {string|!Buffer|!Stream} input The input to replace.\n   * @param {!Object} [context] The context to assign to the new replaceable.\n   */\n  async replace(input, context) {\n    const replaceable = new Replaceable(this.rules, this._options)\n    if (context) Object.assign(replaceable, context)\n    const res = await Replaceable.replace(replaceable, input)\n    if (replaceable._broke) this.brake()\n    if (context) Object.keys(context).forEach(key => {\n      context[key] = replaceable[key]\n    })\n    return res\n  }\n  /**\n   * The method to end the stream with given data, and collect the result.\n   * @param {!Replaceable} replaceable\n   * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n   */\n  static async replace(replaceable, input) {\n    return replace(replaceable, input)\n  }\n\n  /**\n   * Stop executing further after the current rule.\n   */\n  brake() {\n    this._broke = true\n  }\n\n  /**\n   * @param {string|!Buffer} chunk The incoming chunk, or an object if the stream was started in object mode.\n   */\n  async reduce(chunk) {\n    /** @type {string} */\n    const s = await this.rules.reduce(async (acc, { re, replacement }) => {\n      /** @type {string} */\n      let string = await acc\n      if (this._broke) return string\n\n      if (typeof replacement == 'string') {\n        string = string.replace(re, replacement)\n      } else {\n        const promises = []\n        let commonError\n        const t = string.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) {\n              if (promises.length)\n                return promises.push(Promise.resolve(match))\n              return match\n            }\n            const p = replacement.call(this, match, ...args)\n            if (p instanceof Promise) {\n              promises.push(p)\n            }\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        if (promises.length) {\n          try { // hide stack only for when throw happens before awaits\n            const data = await Promise.all(promises)\n            string = string.replace(re, () => data.shift())\n          } catch (e) {\n            hideStack(commonError, e)\n          }\n        } else {\n          string = t\n        }\n      }\n      return string\n    }, `${chunk}`)\n\n    return s\n  }\n  /**\n   * @suppress {checkTypes}\n   * @returns {!Promise}\n   */\n  async _transform(chunk, _, next) {\n    try {\n      const s = await this.reduce(chunk)\n      this.push(s)\n      next()\n    } catch (e) {\n      const s = cleanStack(e.stack)\n      e.stack = s\n      next(e)\n    }\n  }\n}\n\n/**\n * The method to end the stream with given data, and collect the result.\n * @param {!Replaceable} replaceable\n * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n */\nexport async function replace(replaceable, input) {\n  if (input instanceof Stream) {\n    input.pipe(replaceable)\n  } else {\n    replaceable.end(input)\n  }\n  /** @type {string} */\n  const data = await collect(replaceable)\n  return data\n}\n\n/**\n * The class for when serial execution of asynchronous replacements withing the same rule are needed.\n */\nexport class SerialAsyncReplaceable extends Replaceable {\n  /**\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules\n   */\n  constructor(rules) {\n    super(rules)\n    this.promise = Promise.resolve()\n  }\n  addItem(fn) {\n    const pp = this.promise.then(fn)\n    this.promise = pp\n    return pp\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').AsyncReplacer} _restream.AsyncReplacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Replacer} _restream.Replacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').TransformOptions} stream.TransformOptions\n */","import write from '@wrote/write'\nimport read from '@wrote/read'\nimport clone from '@wrote/clone'\nimport ensurePath from '@wrote/ensure-path'\nimport rexml from 'rexml'\nimport argufy, { reduceUsage } from 'argufy'\nimport Catchment, { collect } from 'catchment'\nimport clearr from 'clearr'\n// import competent from 'competent'\nimport erte, { c, b } from 'erte'\nimport forkfeed from 'forkfeed'\nimport makepromise from 'makepromise'\nimport mismatch from 'mismatch'\nimport usually from 'usually'\nimport resolveDependency from 'resolve-dependency'\nimport spawn, { fork } from 'spawncommand'\nimport {\n  SyncReplaceable, Replaceable, makeMarkers, makeCutRule, makePasteRule,\n  replace,\n} from 'restream'\n\nmodule.exports = {\n  'c': c,\n  'b': b,\n  'clone': clone,\n  'ensurePath': ensurePath,\n  'read': read,\n  'replace': replace,\n  'usually': usually,\n  'spawn': spawn,\n  'fork': fork,\n  'SyncReplaceable': SyncReplaceable, \n  'Replaceable': Replaceable, \n  'makeMarkers': makeMarkers, \n  'makeCutRule': makeCutRule, \n  'makePasteRule': makePasteRule,\n  'resolveDependency': resolveDependency,\n  'rexml': rexml,\n  'reduceUsage': reduceUsage,\n  'write': write,\n  'argufy': argufy,\n  'Catchment': Catchment,\n  'collect': collect,\n  'clearr': clearr,\n  // 'competent': competent,\n  'erte': erte,\n  'forkfeed': forkfeed,\n  'makepromise': makepromise,\n  'mismatch': mismatch,\n}","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","/**\n * Generate a usage string.\n * @param {!_usually.Config} config The configuration object.\n * @param {!Object<string, string>} config.usage The map with possible arguments (flags, options) and their information.\n * @param {string} [config.description] What does the program do?\n * @param {string} [config.line] The summary of the program in one line.\n * @param {string} [config.example] The example of the program usage.\n * @example\n```\nimport usually from 'usually'\n\nconst res = usually({\n  usage: {\n    '-h': 'print help',\n    '-c': 'execute this command',\n  },\n  description: 'A test command-line application',\n  line: 'usually [-c command|command2] [-h]',\n  example: 'usually -c command2',\n})\n// A test command-line application\n//\n//  usually [-c command|command2] [-h]\n//\n//        -h      print help\n//        -c      execute this command\n//\n//  Example:\n//\n//    usually -c command2\n//\n```\n */\nexport default function usually(config = { usage: {} }) {\n  const {\n    usage = {},\n    description,\n    line,\n    example,\n  } = config\n  const commands = Object.keys(usage)\n  const descriptions = Object.values(usage)\n\n  const [commandLength] = commands.reduce(([longestName = 0, longestDescription = 0], name) => {\n    const command = usage[name]\n    const theLongest = command.split('\\n')\n      .reduce((acc, c) => {\n        if (c.length > acc) return c.length\n        return acc\n      }, 0)\n    if (theLongest > longestDescription) longestDescription = theLongest\n    if (name.length > longestName) longestName = name.length\n    return [longestName, longestDescription]\n  }, [])\n\n  const pad = (string, length) => {\n    const l = length - string.length\n    const ts = ' '.repeat(l)\n    const s = `${string}${ts}`\n    return s\n  }\n\n  const usa = commands.reduce((acc, command, i) => {\n    const value = descriptions[i]\n    const vals = value.split('\\n')\n    const c = pad(command, commandLength)\n    const [firstVal, ...otherVals] = vals\n    const firstLine = `${c}\\t${firstVal}`\n    const emptyPad = pad('', commandLength)\n    const otherLines = otherVals.map(val => {\n      const r = `${emptyPad}\\t${val}`\n      return r\n    })\n    const res = [...acc, firstLine, ...otherLines]\n    return res\n  }, [])\n\n  const USA = usa.map(a => `\\t${a}`)\n  const s = [\n    description,\n    `  ${line || ''}`,\n  ].filter(l => l ? l.trim() : l).join('\\n\\n')\n  const u = `${s ? `${s}\\n` : ''}\n${USA.join('\\n')}\n`\n\n\n  if (example) {\n    return `${u}\n  Example:\n\n    ${example}\n`\n  }\n\n  return u\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_usually.Config} Config The configuration object.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _usually.Config The configuration object.\n * @prop {!Object<string, string>} usage The map with possible arguments (flags, options) and their information.\n * @prop {string} [description] What does the program do?\n * @prop {string} [line] The summary of the program in one line.\n * @prop {string} [example] The example of the program usage.\n */\n","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","/**\n * Clears the carriage return like the terminal would.\n * @param {string} string The string with the `\\r`.\n * @example\n * const res = clearR('...\\r..?\\r.!')\n * // output: .!?\n */\nconst clearR = (string) => {\n  const st = string.split('\\n').map(l => {\n    const r = l.split('\\r')\n    const t = r.reduce((acc, current, i) => {\n      if (!i) return acc\n      const { length } = current\n      const after = acc.slice(length)\n      return `${current}${after}`\n    }, r[0])\n    return t\n  }).join('\\n')\n  return st\n}\n\nexport default clearR","/**\n * Write data to the `writable` when data from the `readable` matches the regexp.\n * @param {!stream.Readable} readable A readable stream to detect data on.\n * @param {!stream.Writable} stdin A writable stream to pass answers to.\n * @param {!Array<!Array<(!RegExp|string)>>} inputs A serial collection of answers. Each answer will be ended with a `\\n` character. For example, `[[/question/, 'answer'], [/question2/, 'answer2]]`.\n * @param {stream.Writable} [log] A stream to which to write both data from readable, and the passed answer.\n */\nconst forkFeed = (readable, stdin, inputs = [], log = null) => {\n  if (log) readable.on('data', d => log.write(d))\n\n  let [a, ...rest] = inputs\n  if (!a) return\n\n  const handler = (d) => {\n    const [regexp, answer] = a\n    if (!regexp.test(d)) return\n\n    const an = `${answer}\\n`\n    if (log) log.write(an)\n\n    stdin.write(an)\n    ;([a, ...rest] = rest)\n    if (!a) readable.removeListener('data', handler)\n  }\n  readable.on('data', handler)\n}\n\nexport default forkFeed\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Writable} stream.Writable\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n"],
"names":["createReadStream","createWriteStream","lstat","mkdir","readdir","readlink","symlink","fs","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","$jscompDefaultExport","stream","Transform","Writable","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","checkArgumentIndex","i","makePromise","fn","resolveValue","fnLength","resolve","reject","err","error","allArgs","Array","isArray","forEach","arg","basename","dirname","relative","path","ensurePath","dir","make","code","parentDir","lstatFiles","dirPath","dirContent","readFiles","relativePath","ls","all","isDirectory","lstatRes","isNotDirectory","readDirStructure","lsr","directories","files","notDirectories","reduce","acc","current","isFile","isSymbolicLink","type","dirs","structure","content","cloneFile","to","ws","cloneLn","target","cloneDir","pr","keys","k","p","pt","mismatch","string","addPositions","position","start","o","capturedGroup","key","attributeRe","nameRe","valRe","attributesRe","extractProps","simpleAttribute","props","val","parseInt","find","argv","long","short","bool","number","findIndex","a","value","startsWith","findTitles","titles","pushComponent","components","added","removed","last","count","extractCommon","basePath","newString","oldString","diagonalPath","newLen","oldLen","newPos","oldPos","commonCount","equals","removeEmpty","array","ret","diff","Diff","editLength","maxEditLength","bestPath","addPath","removePath","canAdd","canRemove","self","buildValues","left","right","chars","componentPos","componentLen","component","tmp","v","oldValue","lastComponent","pop","colors","backgroundColors","c","color","cc","b","exists","checkSources","pp","fork","spawn","child_process","getPromise","proc","stdout","stderr","checkRule","reObject","replacement","hasRe","hideStack","commonError","thrownError","commonLine","substr","li","lastIndexOf","SyncReplaceable","input","rules","fr","s","_broke","Acc","t","call","brake","replace.brake","getDefaultRegExp","name","toUpperCase","getDefaultReplacement","index","replaceable","Replaceable","_options","context","Replaceable$$module$node_modules$restream$src$Replaceable.replace","promises","data","shift","next","Stream","end","module","exports","clone","read","usually","config","usage","description","line","example","commands","descriptions","values","commandLength","longestName","longestDescription","theLongest","command","pad","ts","repeat","USA","usa","vals","firstVal","otherVals","firstLine","emptyPad","otherLines","l","u","spawnCommand","mod","forkCp","matchers","makeMarkers","getReplacement","getRegex","regExp","lastIndex","marker","makeCutRule","rule","pipeRules","makePasteRule","resolveDependency","relativeFrom","isDir","fileChecked","fileRes","endsWith","tag","extractTags","matches","simple","end1","end2","attributes","attrs","argsConfig","reduceUsage","default","write","argufy","process","commandFound","_argv","boolean","multiple","clearR","after","st","erte","stdin","inputs","log","forkFeed","rest","handler","regexp","answer","an","removeListener","makepromise"]
}
