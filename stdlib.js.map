{
"version":3,
"file":"stdlib.js",
"lineCount":330,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/argufy/src/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/erte/src/diff.js","node_modules/erte/src/index.js","node_modules/makepromise/src/index.js","src/stdlib.js","node_modules/@wrote/write/src/index.js","node_modules/clearr/src/index.js","node_modules/forkfeed/src/index.js","node_modules/mismatch/src/index.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * @param {Array<string>} argv\n * @param {string} long\n * @param {string} [short]\n * @param {boolean} [bool]\n * @param {boolean} [number]\n */\nconst find = (argv, long, short, bool = false, number = false) => {\n  const re = short ? new RegExp(`^-(${short}|-${long})`)\n    : new RegExp(`^--${long}`)\n  const i = argv.findIndex(a => re.test(a))\n  if (i == -1) return { argv }\n\n  if (bool) {\n    return {\n      value: true,\n      argv: [\n        ...argv.slice(0, i),\n        ...argv.slice(i + 1),\n      ],\n    }\n  }\n\n  const j = i + 1\n  let value = argv[j]\n\n  if (!value || (typeof value == 'string' && value.startsWith('--'))) return { argv }\n\n  if (number) {\n    value = parseInt(value, 10)\n  }\n  return {\n    value,\n    argv: [\n      ...argv.slice(0, i),\n      ...argv.slice(j + 1),\n    ],\n  }\n}\n\n/**\n * Parse the config and extract arguments from the `process.argv` array.\n * @param {!_argufy.Config} config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n *\n * - __short__ Shorthand for this argument, usually one letter.\n * - __boolean__ Does not have to be followed by a value, true if given.\n * - __number__ Parse as a number.\n * - __command__ Whether this argument can be specified as the first argument without the dash, such as `example run`.\n * - __multiple__ Extract multiple commands as an  array when `command` is set to true.\n *\n * @example\n```\nconst config = {\n  title: 't',       // program -t Title\n  open: {           // program -o\n    short: 'o',\n    boolean: true,\n  },\n  delay: {          // program -d 100\n    short: 'd',\n    number: true,\n  },\n  file: {           // program File.txt\n    command: true,\n  },\n  file2: {           // program File.txt File2.txt\n    command: true,\n    multiple: true,\n  },\n}\n```\n * @param {!Array<string>} [args] Array with arguments to parse. `process.argv` is used by default. It is assumed that user arguments start from the 3rd position.\n * @returns {Object<string, string|Array<string>|boolean|number>} An object with all found values for the configuration request.\n */\nexport default function argufy(config = {}, args = process.argv) {\n  let [, , ...argv] = args\n  const titles = findTitles(argv)\n  argv = argv.slice(titles.length)\n  let commandFound = !titles.length\n  const res = Object.keys(config).reduce(({ _argv, ...acc }, key) => {\n    if (_argv.length == 0 && commandFound) return { _argv, ...acc }\n    const val = config[key]\n    let value\n    if (typeof val == 'string') {\n      ({ value, argv: _argv } = find(_argv, key, val))\n    } else {\n      try {\n        const { short, boolean, number, command, multiple } = val\n        if (command && multiple && titles.length) {\n          value = titles\n          commandFound = true\n        } else if (command && titles.length) {\n          value = titles[0]\n          commandFound = true\n        } else {\n          ({ value, argv: _argv } = find(_argv, key, short, boolean, number))\n        }\n      } catch (err) {\n        return { _argv, ...acc }\n      }\n    }\n    if (value === undefined) return { _argv, ...acc }\n    const r = { _argv, ...acc, [key]: value }\n    return r\n  }, {\n    _argv: argv,\n  })\n  return res\n}\n\n/** @param {!Array<string>} argv */\nconst findTitles = argv => {\n  const titles = []\n  for (let i = 0; i < argv.length; i++) {\n    const a = argv[i]\n    if (a.startsWith('-')) break\n    titles.push(a)\n  }\n  return titles\n}\n\n/**\n * Based on the argufy config, creates an object that can be passed to `usually`.\n * @param {!_argufy.Config} argsConfig The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n * @example\n```\n{ 'input': 'The input to the program',\n  '--output, -o': 'The output of the program', }\n```\n */\nexport const reduceUsage = (argsConfig) => {\n  const a = Object.keys(argsConfig).reduce((acc, key) => {\n    const val = argsConfig[key]\n    if (typeof val == 'string') {\n      const k = `-${val}`\n      acc[k] = ''\n      return acc\n    }\n    let k = val.command ? key : `--${key}`\n    if (val.short) k = `${k}, -${val.short}`\n    let d = val.description\n    if (val.default) d = `${d}\\nDefault: ${val.default}.`\n    acc[k] = d\n    return acc\n  }, {})\n  return a\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Config} Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, string|!_argufy.Flag>} _argufy.Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Flag} Flag The flag passed to the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _argufy.Flag The flag passed to the program.\n * @prop {string} [short] Shorthand for this argument, usually one letter.\n * @prop {boolean} [boolean=false] Whether the flag is a boolean and does not require a value. Default `false`.\n * @prop {boolean} [number=false] Specifies whether the flag should be parsed as a number. Default `false`.\n * @prop {boolean} [command=false] If set to true, the value is read from the first argument passed to the CLI command (e.g., `$ cli command`). Default `false`.\n * @prop {boolean} [multiple=false] When using the `command` property, will parse the commands as an array. Default `false`.\n * @prop {string} [default] The default value for the argument. Does not actually set the value, only used in reducing the usage info (`argufy` bin on the other hand will set the default).\n * @prop {string} [description] The description to be used by `usually`.\n */\n","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","/**\n * @license diff package https://github.com/kpdecker/jsdiff\n * BSD License\n * Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n */\nexport default class Diff {\n  diff(oldString, newString) {\n    let self = this\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString)\n    newString = this.castInput(newString)\n\n    oldString = this.removeEmpty(this.tokenize(oldString))\n    newString = this.removeEmpty(this.tokenize(newString))\n\n    let newLen = newString.length, oldLen = oldString.length\n    let editLength = 1\n    let maxEditLength = newLen + oldLen\n    let bestPath = [{ newPos: -1, components: [] }]\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return [{ value: this.join(newString), count: newString.length }]\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath\n        let addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          oldPos = (removePath ? removePath.newPos : 0) - diagonalPath\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= oldPos && oldPos < oldLen\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined\n          continue\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath)\n          self.pushComponent(basePath.components, undefined, true)\n        } else {\n          basePath = addPath // No need to clone, we've pulled it from the list\n          basePath.newPos++\n          self.pushComponent(basePath.components, true, undefined)\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newString, oldString)\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath\n        }\n      }\n\n      editLength++\n    }\n\n    while (editLength <= maxEditLength) {\n      let ret = execEditLength()\n      if (ret) {\n        return ret\n      }\n    }\n  }\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1]\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }\n    } else {\n      components.push({ count: 1, added: added, removed: removed })\n    }\n  }\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n\n      commonCount = 0\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++\n      oldPos++\n      commonCount++\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount })\n    }\n\n    basePath.newPos = newPos\n    return oldPos\n  }\n\n  equals(left, right) {\n    return left === right\n  }\n  removeEmpty(array) {\n    let ret = []\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i])\n      }\n    }\n    return ret\n  }\n  castInput(value) {\n    return value\n  }\n  tokenize(value) {\n    return value.split('')\n  }\n  join(chars) {\n    return chars.join('')\n  }\n}\n\nfunction buildValues(diff, components, newString, oldString) {\n  let componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos]\n    if (!component.removed) {\n      if (!component.added) {\n        let value = newString.slice(newPos, newPos + component.count)\n        value = value.map(function(v, i) {\n          let oldValue = oldString[oldPos + i]\n          return oldValue.length > v.length ? oldValue : v\n        })\n\n        component.value = diff.join(value)\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count))\n      }\n      newPos += component.count\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))\n      oldPos += component.count\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1]\n        components[componentPos - 1] = components[componentPos]\n        components[componentPos] = tmp\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1]\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value\n    components.pop()\n  }\n\n  return components\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) }\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import write from '@wrote/write'\nimport argufy, { reduceUsage } from 'argufy'\nimport Catchment, { collect } from 'catchment'\nimport clearr from 'clearr'\n// import competent from 'competent'\nimport erte, { c, b } from 'erte'\nimport forkfeed from 'forkfeed'\nimport makepromise from 'makepromise'\nimport mismatch from 'mismatch'\n\nmodule.exports = {\n  'c': c,\n  'b': b,\n  'reduceUsage': reduceUsage,\n  'write': write,\n  'argufy': argufy,\n  'Catchment': Catchment,\n  'collect': collect,\n  'clearr': clearr,\n  // 'competent': competent,\n  'erte': erte,\n  'forkfeed': forkfeed,\n  'makepromise': makepromise,\n  'mismatch': mismatch,\n}","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","/**\n * Clears the carriage return like the terminal would.\n * @param {string} string The string with the `\\r`.\n * @example\n * const res = clearR('...\\r..?\\r.!')\n * // output: .!?\n */\nconst clearR = (string) => {\n  const st = string.split('\\n').map(l => {\n    const r = l.split('\\r')\n    const t = r.reduce((acc, current, i) => {\n      if (!i) return acc\n      const { length } = current\n      const after = acc.slice(length)\n      return `${current}${after}`\n    }, r[0])\n    return t\n  }).join('\\n')\n  return st\n}\n\nexport default clearR","/**\n * Write data to the `writable` when data from the `readable` matches the regexp.\n * @param {!stream.Readable} readable A readable stream to detect data on.\n * @param {!stream.Writable} stdin A writable stream to pass answers to.\n * @param {!Array<!Array<(!RegExp|string)>>} inputs A serial collection of answers. Each answer will be ended with a `\\n` character. For example, `[[/question/, 'answer'], [/question2/, 'answer2]]`.\n * @param {stream.Writable} [log] A stream to which to write both data from readable, and the passed answer.\n */\nconst forkFeed = (readable, stdin, inputs = [], log = null) => {\n  if (log) readable.on('data', d => log.write(d))\n\n  let [a, ...rest] = inputs\n  if (!a) return\n\n  const handler = (d) => {\n    const [regexp, answer] = a\n    if (!regexp.test(d)) return\n\n    const an = `${answer}\\n`\n    if (log) log.write(an)\n\n    stdin.write(an)\n    ;([a, ...rest] = rest)\n    if (!a) readable.removeListener('data', handler)\n  }\n  readable.on('data', handler)\n}\n\nexport default forkFeed\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Writable} stream.Writable\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}"],
"names":["createWriteStream","fs","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","re","RegExp","source","replace","j","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","find","argv","long","short","bool","number","i","findIndex","a","value","startsWith","parseInt","findTitles","titles","push","Writable","stream","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","pushComponent","components","added","removed","last","count","extractCommon","basePath","newString","oldString","diagonalPath","newLen","oldLen","newPos","oldPos","commonCount","equals","removeEmpty","array","ret","diff","Diff","editLength","maxEditLength","bestPath","addPath","removePath","canAdd","canRemove","self","buildValues","left","right","chars","componentPos","componentLen","component","tmp","v","oldValue","lastComponent","pop","colors","backgroundColors","c","string","color","cc","b","checkArgumentIndex","module","exports","argsConfig","reduceUsage","keys","reduce","acc","key","val","k","command","description","default","write","path","data","ws","err","end","argufy","config","process","commandFound","res","_argv","boolean","multiple","collect","readable","promise","clearR","l","t","current","after","st","erte","target","s","p","stdin","inputs","log","forkFeed","rest","handler","regexp","answer","an","removeListener","makePromise","fn","resolveValue","fnLength","resolve","reject","error","allArgs","Array","isArray","forEach","arg","mismatch","addPositions","position","start","o","capturedGroup"]
}
