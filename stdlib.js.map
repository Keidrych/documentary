{
"version":3,
"file":"stdlib.js",
"lineCount":1198,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/makepromise/src/index.js","node_modules/path/index.js","node_modules/@wrote/ensure-path/src/index.js","node_modules/@wrote/read-dir-structure/src/index.js","node_modules/@wrote/clone/src/index.js","node_modules/mismatch/src/index.js","node_modules/rexml/src/lib/res-simple.js","node_modules/rexml/src/index.js","node_modules/rexml/src/lib/index.js","node_modules/argufy/src/index.js","node_modules/@depack/render/src/util.js","node_modules/@depack/render/src/lib/index.js","node_modules/@depack/render/src/index.js","node_modules/restream/src/lib/index.js","node_modules/restream/src/SyncReplaceable.js","node_modules/restream/src/lib/markers.js","node_modules/restream/src/Replaceable.js","node_modules/competent/src/lib/index.js","node_modules/erte/src/diff.js","node_modules/erte/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/resolve-dependency/src/index.js","node_modules/child_process/index.js","node_modules/spawncommand/src/index.js","node_modules/util/index.js","node_modules/pedantry/src/lib/index.js","node_modules/pedantry/src/index.js","node_modules/crypto/index.js","node_modules/module/index.js","node_modules/@depack/detect/src/index.js","node_modules/fpj/src/index.js","node_modules/static-analysis/src/lib.js","node_modules/@depack/split/src/index.js","node_modules/static-analysis/src/index.js","node_modules/@depack/cache/src/lib.js","node_modules/which-stream/src/index.js","src/stdlib.js","node_modules/competent/src/index.js","node_modules/@depack/cache/src/index.js","node_modules/usually/src/index.js","node_modules/@wrote/write/src/index.js","node_modules/clearr/src/index.js","node_modules/forkfeed/src/index.js"],
"sourcesContent":["export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import { mkdir, mkdirSync } from 'fs'\nimport makePromise from 'makepromise'\nimport { dirname } from 'path'\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport default async function ensurePath(path) {\n  const dir = dirname(path)\n  try {\n    await make(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nasync function make(dir) {\n  try {\n    await makePromise(mkdir, dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      await make(parentDir)\n      await make(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}\n\n/**\n * Makes sure that a file can be created by creating all directories to which it belongs to synchronously, e.g., `ensurePath('~/path/to/wrote.data')` will attempt to create `~/path/to` directory recursively.\n * @param {string} path The path to the file.\n * @throws {Error} When the first folder in the path is non-executable.\n */\nexport function ensurePathSync(path) {\n  const dir = dirname(path)\n  try {\n    makeSync(dir)\n    return path\n  } catch (err) {\n    if (/EEXIST/.test(err.message) && err.message.indexOf(dir) != -1) {\n      return path\n    }\n    throw err\n  }\n}\n\n/**\n * Recursive promise-based mkdir.\n * @param {string} dir Path to the directory to be created\n */\nfunction makeSync(dir) {\n  try {\n    mkdirSync(dir)\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      const parentDir = dirname(dir)\n      makeSync(parentDir)\n      makeSync(dir)\n    } else if (err.code != 'EEXIST') { // created in parallel\n      throw err\n    }\n  }\n}","import { lstat, readdir } from 'fs'\nimport makePromise from 'makepromise'\nimport { join } from 'path'\n\n/**\n * Update information about directory's content with lstat.\n * @param {string} dirPath Path to the root directory\n * @param {!Array<string>} dirContent\n * @returns {Promise<Array<_readDirStructure.File>>} An array with file objects.\n */\nasync function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}\n\n/**\n * Check if lstat result is a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is a directory\n */\nconst isDirectory = lstatRes => lstatRes.lstat.isDirectory()\n/**\n * Check if lstat result is not a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is not a directory\n */\nconst isNotDirectory = lstatRes => !lstatRes.lstat.isDirectory()\n\nconst getType = (lstatRes) => {\n  if (lstatRes.lstat.isDirectory()) {\n    return 'Directory'\n  }\n  if (lstatRes.lstat.isFile()) {\n    return 'File'\n  }\n  if (lstatRes.lstat.isSymbolicLink()) {\n    return 'SymbolicLink'\n  }\n}\n\n/**\n * Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n * @param {string} dirPath Path to the directory.\n * @returns {Promise<_readDirStructure.DirectoryStructure>} An object reflecting the directory structure.\n * @example\n```js\nconst res = await readDirStructure('dir')\n// result:\n{\n  type: 'Directory',\n  content: {\n    'data.txt': {\n      type: 'File'\n    },\n    subdir: {\n      type: 'Directory',\n      content: {\n        'data-ln.txt': {\n          type: 'SymbolicLink'\n        },\n      }\n    }\n  }\n}\n```\n */\nexport default async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}\n\n/**\n * After running the `readDirStructure`, this function can be used to flatten the `content` output and return the list of all files (not including symlinks).\n * @param {!_readDirStructure.Content} content The recursive content of the directory.\n * @param {string} path The path to the directory.\n */\nexport const getFiles = (content, path) => {\n  let files = []\n  let dirs = []\n  Object.keys(content).forEach((key) => {\n    const { type } = content[key]\n    if (type == 'File') files.push(join(path, key))\n    else if (type == 'Directory') dirs.push(key)\n  })\n  const dirFiles = dirs.reduce((acc, dir) => {\n    const { content: c } =\n      /** @type {!_readDirStructure.Content} */ (content[dir])\n    const f = getFiles(c, join(path, dir))\n    return [...acc, ...f]\n  }, [])\n  return [...files, ...dirFiles]\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.File} File\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.File\n * @prop {!fs.Stats} lstat The stats of the item.\n * @prop {string} path The full path of the item.\n * @prop {string} relativePath The name of the item.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.Content} Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, !_readDirStructure.DirectoryStructure>} _readDirStructure.Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.DirectoryStructure} DirectoryStructure A directory structure representation.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.DirectoryStructure A directory structure representation.\n * @prop {string} [type] The type of the item.\n * @prop {!_readDirStructure.Content} [content] The recursive content if the item is a directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */\n","import ensurePath from '@wrote/ensure-path'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport makePromise from 'makepromise'\nimport {\n  createReadStream, createWriteStream, lstat, readlink, symlink,\n} from 'fs'\nimport { join, basename } from 'path'\n\n/**\n * Clone a file.\n * @param {string} from Path to the file which to clone.\n * @param {string} to Path to the file where to clone.\n */\nconst cloneFile = async (from, to) => {\n  const rs = createReadStream(from)\n  const ws = createWriteStream(to)\n  rs.pipe(ws)\n  await Promise.all([\n    new Promise((r, j) => {\n      rs.on('close', r).on('error', j)\n    }),\n    new Promise((r, j) => {\n      ws.on('close', r).on('error', j)\n    }),\n  ])\n}\n\nconst cloneLn = async (from, to) => {\n  const target = await makePromise(readlink, from)\n  await makePromise(symlink, [target, to])\n}\n\n/**\n * Clones a directory.\n * @param {string} from Path of the file or directory being cloned.\n * @param {string} to Path to the cloned directory (not its parent!).\n */\nconst cloneDir = async (from, to) => {\n  await ensurePath(join(to, 'path.file'))\n  const { content } = await readDirStructure(from)\n  const pr = Object.keys(/** @type {!Object} */ (content)).map(async (k) => {\n    const { type } = content[k]\n    const p = join(from, k)\n    const pt = join(to, k)\n    if (type == 'Directory') {\n      await cloneDir(p, pt)\n    } else if (type == 'File') {\n      await cloneFile(p, pt)\n    } else if (type == 'SymbolicLink') {\n      await cloneLn(p, pt)\n    }\n  })\n  await Promise.all(pr)\n}\n\n/**\n * Clone a file or directory.\n * @param {string} path Path to the file or directory to clone.\n * @param {string} to Path to the directory to contain the file or directory being cloned (not the path to the cloned entity).\n */\nconst clone = async (path, to) => {\n  const s = /** @type {!fs.Stats} */ (await makePromise(lstat, path))\n  const b = basename(path)\n  const t = join(to, b)\n\n  if (s.isDirectory()) {\n    await cloneDir(path, t)\n  } else if (s.isSymbolicLink()) {\n    await cloneLn(path, t)\n  } else {\n    await ensurePath(t)\n    await cloneFile(path, t)\n  }\n}\n\nexport default clone\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","const nameRe = /([^\\s>=/]+)/\nconst valRe = /(?:\"([\\s\\S]*?)\"|'([\\s\\S]*?)')/\n\nexport const attributeRe = new RegExp(`${nameRe.source}(?:\\\\s*=\\\\s*${valRe.source})?`, 'g')\n\n/**\n * This regex will match all attributes as a string inside of element, e.g., matching `<el attr=\"abc\" bool/>` will result in `attr=\"abc\" bool`.\n */\nexport const attributesRe = new RegExp(`(?:\\\\s+((?:${attributeRe.source}\\\\s*)*))`)\n","import mismatch from 'mismatch'\nimport { extractProps as extractPropsSpec, getPropValue } from './lib'\nimport { attributesRe } from './lib/res'\nimport { attributesRe as simple, attributeRe as simpleAttribute } from './lib/res-simple'\n\nconst execRes = (re, s) => {\n  const res = re.exec(s)\n  if (!res) return res\n  const [, ...args] = res\n  return args\n}\n\n/**\n * Extract member elements from an XML string. Numbers and booleans will be parsed into their JS types.\n * @param {string|!Array<string>} tag Which tag to extract, e.g., `div`. Can also pass an array of tags, in which case the name of the tag will also be returned.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n * <html>\n *   <div id=\"1\" class=\"test\" contenteditable>\n *     Hello World\n *   </div>\n * </html>\n * `\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nconst extractTags = (tag, string) => {\n  const tags = Array.isArray(tag) ? tag : [tag]\n  const t = tags.join('|')\n  const end1 = /\\s*\\/>/\n  const end2 = />([\\s\\S]+?)?<\\/\\1>/\n  const re = new RegExp(`<(${t})${simple.source}?(?:${end1.source}|${end2.source})`, 'g')\n\n  const matches = mismatch(re, string, ['t', 'a', 'v', 'v1', 'v2', 'c'])\n  const res = matches.map(({ 't': tagName, 'a': attributes = '', 'c': content = '' }) => {\n    const attrs = attributes.replace(/\\/$/, '').trim()\n    const props = extractProps(attrs)\n    return { content, props, tag: tagName }\n  })\n  return res\n}\n\n/**\n * Extracts the properties from the attributes part of the tag and returns them as an object. It will parse values if not specified otherwise.\n * @param {string} string The attribute part of the tag.\n * @param {boolean} parseValue Whether to transform the value into its value.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const m = mismatch(simpleAttribute, string, ['key', 'val', 'def', 'f'])\n  const props = m\n    .reduce((acc, { 'key': key, 'val': val }) => {\n      if (val === undefined) {\n        acc[key] = true\n        return acc\n      }\n      acc[key] = parseValue ? getPropValue(val) : val\n      return acc\n    }, {})\n  return props\n}\n\n/**\n * Extract member elements from an XML string using the complex regular expression to match attributes that confirms to the XML spec. Numbers and booleans will be parsed into their JS types.\n * @param {string} tag Which tag to extract, e.g., `div`.\n * @param {string} string The XML string.\n * @example\n *\n * const xml = `\n<html>\n  <div id=\"1\" class=\"test\" contenteditable>\n    Hello World\n  </div>\n</html>\n`\n * const [{ content, props }] = extractTag('div', xml)\n * // content: Hello World\n * // props: { id: 1, class: 'test', contenteditable: true }\n */\nexport const extractTagsSpec = (tag, string) => {\n  const end1 = /\\s*\\/>/\n  const end2 = new RegExp(`>([\\\\s\\\\S]+?)?</${tag}>`)\n  const re = new RegExp(`<${tag}${attributesRe.source}?(?:${end1.source}|${end2.source})`, 'gu')\n  const r = []\n\n  let t\n  while ((t = execRes(re, string))) {\n    if (!t.length) continue\n    const [_p = '', _c = ''] = t\n    const p = _p.replace(/\\/$/, '').trim()\n    const props = extractProps(p)\n    const item = {\n      props,\n      content: _c,\n    }\n    r.push(item)\n  }\n  return r\n}\n\nexport default extractTags\nexport { extractPropsSpec }","import { attributeRe } from './res'\n\nexport const getPropValue = (val) => {\n  if (val == 'true') return true\n  if (val == 'false') return false\n  if (/^\\d+$/.test(val)) {\n    return parseInt(val, 10)\n  }\n  return val\n}\n\n/**\n * Parse the arguments part of an XML element\n * @param {string} string String to extract attributes from.\n * @param {boolean} parseValue Parse `true` and `false` values into a boolean, and numbers into integers. Default `true`.\n */\nexport const extractProps = (string, parseValue = true) => {\n  const o = {}\n  const re = new RegExp(`\\\\s+${attributeRe.source}`, 'gu')\n  ;` ${string}`.replace(re, (match, name,  doubleQuoteVal, singleQuoteVal) => {\n    const value = singleQuoteVal || doubleQuoteVal\n    const v = value === undefined ? true : value\n    const val = parseValue ? getPropValue(v) : v\n    o[name] = val\n  })\n  return o\n}\n","/**\n * @param {Array<string>} argv\n * @param {string} long\n * @param {string} [short]\n * @param {boolean} [bool]\n * @param {boolean} [number]\n */\nconst find = (argv, long, short, bool = false, number = false) => {\n  const re = short ? new RegExp(`^-(${short}|-${long})`)\n    : new RegExp(`^--${long}`)\n  const i = argv.findIndex(a => re.test(a))\n  if (i == -1) return { argv }\n\n  if (bool) {\n    return {\n      value: true,\n      argv: [\n        ...argv.slice(0, i),\n        ...argv.slice(i + 1),\n      ],\n    }\n  }\n\n  const j = i + 1\n  let value = argv[j]\n\n  if (!value || (typeof value == 'string' && value.startsWith('--'))) return { argv }\n\n  if (number) {\n    value = parseInt(value, 10)\n  }\n  return {\n    value,\n    argv: [\n      ...argv.slice(0, i),\n      ...argv.slice(j + 1),\n    ],\n  }\n}\n\n/**\n * Parse the config and extract arguments from the `process.argv` array.\n * @param {!_argufy.Config} config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n *\n * - __short__ Shorthand for this argument, usually one letter.\n * - __boolean__ Does not have to be followed by a value, true if given.\n * - __number__ Parse as a number.\n * - __command__ Whether this argument can be specified as the first argument without the dash, such as `example run`.\n * - __multiple__ Extract multiple commands as an  array when `command` is set to true.\n *\n * @example\n```\nconst config = {\n  title: 't',       // program -t Title\n  open: {           // program -o\n    short: 'o',\n    boolean: true,\n  },\n  delay: {          // program -d 100\n    short: 'd',\n    number: true,\n  },\n  file: {           // program File.txt\n    command: true,\n  },\n  file2: {           // program File.txt File2.txt\n    command: true,\n    multiple: true,\n  },\n}\n```\n * @param {!Array<string>} [args] Array with arguments to parse. `process.argv` is used by default. It is assumed that user arguments start from the 3rd position.\n * @returns {Object<string, string|Array<string>|boolean|number>} An object with all found values for the configuration request.\n */\nexport default function argufy(config = {}, args = process.argv) {\n  let [, , ...argv] = args\n  const titles = findTitles(argv)\n  argv = argv.slice(titles.length)\n  let commandFound = !titles.length\n  const res = Object.keys(config).reduce(({ _argv, ...acc }, key) => {\n    if (_argv.length == 0 && commandFound) return { _argv, ...acc }\n    const val = config[key]\n    let value\n    if (typeof val == 'string') {\n      ({ value, argv: _argv } = find(_argv, key, val))\n    } else {\n      try {\n        const { short, boolean, number, command, multiple } = val\n        if (command && multiple && titles.length) {\n          value = titles\n          commandFound = true\n        } else if (command && titles.length) {\n          value = titles[0]\n          commandFound = true\n        } else {\n          ({ value, argv: _argv } = find(_argv, key, short, boolean, number))\n        }\n      } catch (err) {\n        return { _argv, ...acc }\n      }\n    }\n    if (value === undefined) return { _argv, ...acc }\n    const r = { _argv, ...acc, [key]: value }\n    return r\n  }, {\n    _argv: argv,\n  })\n  return res\n}\n\n/** @param {!Array<string>} argv */\nconst findTitles = argv => {\n  const titles = []\n  for (let i = 0; i < argv.length; i++) {\n    const a = argv[i]\n    if (a.startsWith('-')) break\n    titles.push(a)\n  }\n  return titles\n}\n\n/**\n * Based on the argufy config, creates an object that can be passed to `usually`.\n * @param {!_argufy.Config} argsConfig The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n * @example\n```\n{ 'input': 'The input to the program',\n  '--output, -o': 'The output of the program', }\n```\n */\nexport const reduceUsage = (argsConfig) => {\n  const a = Object.keys(argsConfig).reduce((acc, key) => {\n    const val = argsConfig[key]\n    if (typeof val == 'string') {\n      const k = `-${val}`\n      acc[k] = ''\n      return acc\n    }\n    let k = val.command ? key : `--${key}`\n    if (val.short) k = `${k}, -${val.short}`\n    let d = val.description\n    if (val.default) d = `${d}\\nDefault: ${val.default}.`\n    acc[k] = d\n    return acc\n  }, {})\n  return a\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Config} Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, string|!_argufy.Flag>} _argufy.Config The configuration for parsing, where each key is a flag name and values are either strings, or objects with possible properties:\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_argufy.Flag} Flag The flag passed to the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _argufy.Flag The flag passed to the program.\n * @prop {string} [short] Shorthand for this argument, usually one letter.\n * @prop {boolean} [boolean=false] Whether the flag is a boolean and does not require a value. Default `false`.\n * @prop {boolean} [number=false] Specifies whether the flag should be parsed as a number. Default `false`.\n * @prop {boolean} [command=false] If set to true, the value is read from the first argument passed to the CLI command (e.g., `$ cli command`). Default `false`.\n * @prop {boolean} [multiple=false] When using the `command` property, will parse the commands as an array. Default `false`.\n * @prop {string} [default] The default value for the argument. Does not actually set the value, only used in reducing the usage info (`argufy` bin on the other hand will set the default).\n * @prop {string} [description] The description to be used by `usually`.\n */\n","// DOM properties that should NOT have \"px\" added when numeric\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i\n\nexport let encodeEntities = s => `${s}`\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/\"/g, '&quot;')\n\nexport let indent = (s, char) => `${s}`.replace(/(\\n+)/g, '$1' + (char || '\\t'))\n\nexport let isLargeString = (s, length = 40, ignoreLines = false) => (`${s}`.length>length || (!ignoreLines && `${s}`.indexOf('\\n')!=-1) || `${s}`.indexOf('<')!==-1)\n\nconst JS_TO_CSS = {}\n\n/**\n * Convert an Object style to a CSSText string.\n * @param {!Object} s\n */\nexport function styleObjToCss(s) {\n  let str = ''\n  for (let prop in s) {\n    let val = s[prop]\n    if (val!=null) {\n      if (str) str += ' '\n      // str += jsToCss(prop);\n      str += JS_TO_CSS[prop] || (JS_TO_CSS[prop] = prop.replace(/([A-Z])/g,'-$1').toLowerCase())\n      str += ': '\n      str += val\n      if (typeof val=='number' && IS_NON_DIMENSIONAL.test(prop)===false) {\n        str += 'px'\n      }\n      str += ';'\n    }\n  }\n  return str || undefined\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {!preact.VNode} vnode The VNode to get props for\n */\nexport function getNodeProps(vnode) {\n  const props = {\n    ...vnode.attributes, children: vnode.children,\n  }\n\n  let defaultProps = vnode.nodeName.defaultProps\n  if (defaultProps!==undefined) {\n    for (let i in defaultProps) {\n      if (props[i]===undefined) {\n        props[i] = defaultProps[i]\n      }\n    }\n  }\n\n  return props\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').VNode} preact.VNode\n */","import { encodeEntities, styleObjToCss } from '../util'\n\n/**\n * Maps attributes to `name=\"value\"` strings, and returns html if dangerouslySetInnerHTML is given.\n * @param {!Object<string, ?>} attributes\n * @param {string} nodeName\n * @param {Object} [props]\n * @param {boolean} [props.allAttributes=false]\n * @param {boolean} [props.xml=false]\n * @param {boolean} [props.isSvgMode=false]\n * @param {boolean} [props.sort=false]\n */\nexport const mapAttributes = (attributes, nodeName, {\n  allAttributes, xml, isSvgMode, sort, selectValue,\n} = {}) => {\n  let html\n  const attrs = Object.keys(attributes)\n  if (sort) attrs.sort()\n  const a = attrs.map((name) => {\n    let v = attributes[name]\n    if (name == 'children') return\n    if (name.match(/[\\s\\n\\\\/='\"\\0<>]/)) return\n    if (!allAttributes && ['key', 'ref'].includes(name)) return\n    if (name == 'className') {\n      if (attributes.class) return // class takes precedence\n      name = 'class'\n    } else if (name == 'htmlFor') {\n      if (attributes.for) return // class takes precedence\n      name = 'for'\n    } else if (name == 'srcSet') {\n      if (attributes.srcset) return // srcset takes precedence\n      name = 'srcset'\n    }\n    if (isSvgMode && name.match(/^xlink:?./)) {\n      name = name.toLowerCase().replace(/^xlink:?/, 'xlink:')\n    }\n    if (name == 'style' && v && typeof v == 'object') {\n      v = styleObjToCss(v)\n    }\n    if (name == 'dangerouslySetInnerHTML') {\n      html = v && v.__html // side-effect\n    } else if ((v || v===0 || v==='') && typeof v!='function') {\n      if (v===true || v==='') {\n        v = name\n        // in non-xml mode, allow boolean attributes\n        if (!xml) return name\n      }\n      let s = ''\n      if (name == 'value') {\n        if (nodeName == 'select') {\n          selectValue = v\n          return\n        } else if (nodeName == 'option' && selectValue == v) {\n          s = 'selected '\n        }\n      }\n      return `${s}${name}=\"${encodeEntities(v)}\"`\n    }\n  }).filter(Boolean)\n  return { mappedAttributes: a, html, selectValue }\n}\n\nexport const inlineElements = [\n  'a', 'abbr', 'acronym', 'audio', 'b', 'bdi', 'bdo', 'big', 'br',\n  'button', 'canvas', 'cite', 'code', 'data', 'datalist', 'del',\n  'dfn', 'em', 'embed', 'i', 'iframe', 'img', 'input', 'ins',\n  'kbd', 'label', 'map', 'mark', 'meter', 'noscript', 'object',\n  'output', 'picture', 'progress', 'q', 'ruby', 's', 'samp',\n  'slot', 'small', 'span', 'strong', 'sub',\n  'sup', 'svg', 'template', 'textarea', 'time', 'u', 'tt', 'var',\n  'video', 'wbr',\n]","import { encodeEntities, indent, isLargeString, getNodeProps } from './util'\nimport { mapAttributes, inlineElements } from './lib'\n\n// components without names, kept as a hash for later comparison to return consistent UnnamedComponentXX names.\nconst UNNAMED = []\n\nconst VOID_ELEMENTS = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/\nconst INLINE_ELEMENTS = new RegExp(`^(${inlineElements.join('|')})$`)\n\n/** Only render elements, leaving Components inline as `<ComponentName ... />`.\n * This method is just a convenience alias for `render(vnode, context, { shallow:true })`\n * @param {preact.VNode} vnode JSX VNode to render.\n * @param {!Object} [context]  Optionally pass an initial context object through the render path.\n */\nconst shallowRender = (vnode, context) => renderToString(vnode, { shallow: true }, context)\n\n// const prettyAttributeHook = (name, value, context, opts) => {\n//   let indentChar = typeof opts.pretty=='string' ? opts.pretty : '  '\n//   return `\\n${indentChar}${name}=\"${encodeEntities(value)}\"`\n// }\n\n/**\n * Render Preact JSX Components to an HTML string.\n * @param {preact.VNode} vnode JSX VNode to render.\n * @param {!_depack.RenderConfig} [config] Rendering options.\n */\nconst render = (vnode, config = {}, context = {}) => {\n  const { addDoctype, pretty } = config\n  const res = renderToString(vnode, config, context)\n  if (addDoctype) return `<!doctype html>${pretty ? '\\n': ''}${res}`\n  return res\n}\n\n/** Render Preact JSX + Components to an HTML string.\n * @param {preact.VNode|boolean|number|string|undefined} vnode\n * @param {!_depack.RenderConfig} [opts]\n * @param {!Object} [context]\n * @param {boolean} [inner]\n * @param {boolean} [isSvgMode]\n * @param {string} [selectValue] Used to set the value of options via select's value `attribute`.\n */\nfunction renderToString(\n  vnode, opts = {}, context = {}, inner = false, isSvgMode = false, selectValue,\n) {\n  if (vnode==null || typeof vnode=='boolean') {\n    return ''\n  }\n\n  const {\n    pretty = false,\n    shallow = false,\n    renderRootComponent = false,\n    shallowHighOrder = false,\n    sortAttributes,\n    allAttributes,\n    xml,\n    initialPadding = 0,\n    closeVoidTags = false,\n  } = opts\n\n  let { lineLength = 40 } = opts\n  lineLength -= initialPadding\n\n  let { nodeName, attributes = {} } = vnode\n\n  const noPretty = ['textarea', 'pre'].includes(nodeName)\n  const ip = ' '.repeat(initialPadding)\n\n  const indentChar = typeof pretty == 'string' ? pretty :\n    `  ${ip}`\n\n  // #text nodes\n  if (typeof vnode!='object' && !nodeName) {\n    return encodeEntities(vnode)\n  }\n\n  // components\n  if (typeof nodeName=='function') {\n    // nodeName = /** @type {!Function} */ (nodeName)\n    if (shallow && (inner || !renderRootComponent)) {\n      nodeName = getComponentName(nodeName)\n    }\n    else {\n      let props = getNodeProps(/** @type {!preact.VNode} */ (vnode)),\n        rendered\n\n      if (!nodeName.prototype || typeof nodeName.prototype.render!='function') {\n        // stateless functional components\n        rendered = nodeName(props, context)\n      }\n      else {\n        // class-based components\n        let c = /** @type {!preact.Component} */ (new nodeName(props, context))\n        // turn off stateful re-rendering:\n        c._disable = c.__x = true\n        c.props = props\n        c.context = context\n        if (nodeName.getDerivedStateFromProps) c.state = {\n          ...c.state,\n          ...nodeName.getDerivedStateFromProps(c.props, c.state),\n        }\n        else if (c.componentWillMount) c.componentWillMount()\n        rendered = c.render(c.props, c.state, c.context)\n\n        if (c.getChildContext) {\n          context = { ...context, ...c.getChildContext() }\n        }\n      }\n\n      return renderToString(rendered, opts, context, shallowHighOrder, isSvgMode, selectValue)\n    }\n  }\n\n  // render JSX to HTML\n  let s = '', html\n\n  let mappedAttributes\n  ;({ mappedAttributes, html, selectValue } = mapAttributes(/** @type {!Object} */ (attributes), nodeName, {\n    allAttributes, xml, isSvgMode, sort: sortAttributes, selectValue,\n  }))\n\n  // account for >1 multiline attribute\n  if (pretty) {\n    const nl = `<${nodeName}`\n    let cl = nl.length\n    s = mappedAttributes.reduce((acc, current) => {\n      const newLength = cl + 1 + current.length\n      if (newLength > lineLength) {\n        cl = indentChar.length\n        return `${acc}\\n${indentChar}${current}`\n      }\n      cl = newLength\n      return `${acc} ${current}`\n    }, '')\n  } else {\n    s = mappedAttributes.length ? ' ' + mappedAttributes.join(' ') : ''\n  }\n\n  s = `<${nodeName}${s}>`\n  if (`${nodeName}`.match(/[\\s\\n\\\\/='\"\\0<>]/)) throw s\n\n  let isVoid = `${nodeName}`.match(VOID_ELEMENTS)\n  if (closeVoidTags) {\n    if (isVoid) s = s.replace(/>$/, ' />')\n  }\n\n  let pieces = []\n  if (html) {\n    // if multiline, indent.\n    if (pretty && (isLargeString(html) || html.length + getLastLineLength(s) > lineLength)) {\n      html = '\\n' + indentChar + indent(html, indentChar)\n    }\n    s += html\n  }\n  else if (vnode.children) {\n    let hasLarge = pretty && s.includes('\\n')\n    pieces = vnode.children.map((child) => {\n      if (child==null || child===false) return\n      const childSvgMode = nodeName == 'svg' ? true : nodeName == 'foreignObject' ? false : isSvgMode\n      const ret = renderToString(child, opts, context, true, childSvgMode, selectValue)\n      if (!ret) return\n      if (pretty && ret.length + getLastLineLength(s) > lineLength)\n        hasLarge = true\n      return ret\n    }).filter(Boolean)\n\n    if (pretty && hasLarge && !noPretty) {\n      for (let i=pieces.length; i--;) {\n        pieces[i] = '\\n' + indentChar + indent(pieces[i], indentChar)\n      }\n    }\n  }\n\n  if (pieces.length) {\n    s += pieces.join('')\n  }\n  else if (xml) {\n    return s.substring(0, s.length-1) + ' />'\n  }\n\n  if (!isVoid) {\n    // inline elements should not have additional whitespace\n    // however if there were other tags inside them, that should be fine\n    const lastPiece = pieces[pieces.length - 1]\n    const isInline = `${nodeName}`.match(INLINE_ELEMENTS) && (lastPiece ? !/>$/.test(lastPiece) : true)\n    if (!isInline && !noPretty && pretty && s.includes('\\n')) s += `\\n${ip}`\n    s += `</${nodeName}>`\n  }\n\n  return s\n}\n\n/**\n * @param {!Function} component\n */\nfunction getComponentName(component) {\n  return component.displayName || component!==Function && component.name || getFallbackComponentName(component)\n}\n\n/**\n * @param {!Function} component\n */\nfunction getFallbackComponentName(component) {\n  /** @type {string} */\n  const str = Function.prototype.toString.call(component)\n\n  let name = (str.match(/^\\s*function\\s+([^( ]+)/) || '')[1]\n  if (!name) {\n    // search for an existing indexed name for the given component:\n    let index = -1\n    for (let i=UNNAMED.length; i--; ) {\n      if (UNNAMED[i]===component) {\n        index = i\n        break\n      }\n    }\n    // not found, create a new indexed name:\n    if (index<0) {\n      index = UNNAMED.push(component) - 1\n    }\n    name = `UnnamedComponent${index}`\n  }\n  return name\n}\n\nexport default render\n\nexport { shallowRender }\n\nconst getLastLineLength = (s) => {\n  const st = s.split('\\n')\n  const lastLine = st[st.length - 1]\n  return lastLine.length\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').RenderConfig} _depack.RenderConfig\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').VNode} preact.VNode\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Component} preact.Component\n */","export function checkRule(reObject) {\n  if (typeof reObject != 'object') {\n    return false\n  }\n  const { re, replacement } = reObject\n  const hasRe = re instanceof RegExp\n  const type = ['string', 'function'].indexOf(typeof replacement) != -1\n  return hasRe && type\n}\n\nexport const hideStack = (commonError, thrownError) => {\n  if (!(thrownError instanceof Error)) throw thrownError\n  const [, , commonLine] = commonError.stack.split('\\n', 3)\n  const i = thrownError.stack.indexOf(commonLine)\n  if (i == -1) throw thrownError\n  const stack = thrownError.stack.substr(0, i - 1)\n  const li = stack.lastIndexOf('\\n')\n  thrownError.stack = stack.substr(0, li)\n  throw thrownError\n}","import { checkRule, hideStack } from './lib'\n\n/**\n  * _SyncReplaceable_ function receives the whole string and returns the result of transform rules which are either sync function replacers or string replacements (see https://github.com/artdecocode/restream#rule-type for more info). This is not a class and just a function.\n  * @param {string|!Buffer} input The string or buffer to transform synchronously using the replacements. Does not support asynchronous replacements.\n  * @param {!Array<!_restream.Rule>} rules An array with rules.\n  * @return {string}\n  * @example\n```\n// markdown __ to html <em> implementation\nconst stream = SyncReplaceable('__hello world__', {\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n  */\nfunction SyncReplaceable(input, rules) {\n  /**\n   * @suppress {globalThis}\n   */\n  function replace() {\n    const fr = rules.filter(checkRule)\n    const s = fr.reduce((acc, { re, replacement }) => {\n      /** @type {string} */\n      let Acc = acc\n      if (this._broke) return Acc\n\n      if (typeof replacement == 'string') {\n        Acc = Acc.replace(re, replacement)\n        return Acc\n      } else {\n        let commonError\n        const t = Acc.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) return match\n            const p = replacement.call(this, match, ...args)\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        return t\n      }\n    }, `${input}`)\n    return s\n  }\n  replace.brake = () => { replace._broke = true }\n  return replace.call(replace)\n}\n\nexport default SyncReplaceable\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */","import SyncReplaceable from '../SyncReplaceable'\n\n/**\n * @param {string} name\n */\nconst getDefaultRegExp = (name) => {\n  return new RegExp(`%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_(\\\\d+)_%%`, 'g')\n}\n\n/**\n * Make a unique string to replace cut text with.\n * @param {string} name\n * @param {number} index\n */\nconst getDefaultReplacement = (name, index) => {\n  return `%%_RESTREAM_${name.toUpperCase()}_REPLACEMENT_${index}_%%`\n}\n\n/**\n * Create a new marker.\n * @param {string} name The name of the matcher, used in the doc marker.\n * @param {!RegExp} re The regular expression used for detection.\n * @param {!_restream.MakeMarkersConfig} [conf] Additional configuration.\n * @param {function(string, number): string} [conf.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [conf.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @return {!_restream.Marker} The marker.\n */\nconst makeMarker = (name, re, conf) => {\n  const {\n    getReplacement = getDefaultReplacement,\n    getRegex = getDefaultRegExp,\n  } = conf || {}\n  const regExp = getRegex(name)\n  return {\n    name,\n    re,\n    regExp,\n    getReplacement,\n    map: {},\n    lastIndex: 0,\n  }\n}\n\n/**\n * Make markers from a configuration object.\n * @param {!Object.<string, !RegExp>} matchers An object with types of markers to create as keys and their detection regexes as values.\n * @param {!_restream.MakeMarkersConfig} [config] Additional configuration.\n * @param {function(string, number): string} [config.getReplacement] The function used to create a replacement when some text needs to be cut.\n * @param {function(string): !RegExp} [config.getRegex] The function used to create a RegExp to detect replaced chunks.\n * @returns {!Object.<string, !_restream.Marker>} An object with markers for each requested type.\n */\nexport const makeMarkers = (matchers, config) => {\n  const res = Object.keys(matchers).reduce((acc, key) => {\n    const re = matchers[key]\n    const marker = makeMarker(key, re, config)\n    const m = {\n      ...acc,\n      [key]: marker,\n    }\n    return m\n  }, {})\n  return res\n}\n\n/**\n * Make a rule for pasting markers back.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @param {!(_restream.Rule|Array<!_restream.Rule>)} [pipeRules] Any additional rules to replace the value of the marker before pasting it.\n * @returns {!_restream.Rule} A rule to paste previously replaced chunks.\n */\nexport const makePasteRule = (marker, pipeRules = []) => {\n  const { regExp: re, map } = marker\n  const rule = {\n    re,\n    replacement(match, index) {\n      const m = map[index]\n      delete map[index]\n      const pr = Array.isArray(pipeRules) ? pipeRules : [pipeRules]\n      const res = SyncReplaceable(m, pr)\n      return res\n    },\n  }\n  return rule\n}\n\n/**\n * Make a rule for initial replacement of markers.\n * @param {!_restream.Marker} marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @returns {!_restream.Rule} A rule to cut matched chunks.\n */\nexport const makeCutRule = (marker) => {\n  const { re, map, getReplacement, name } = marker\n  const rule = {\n    re,\n    replacement(match) {\n      const { lastIndex } = marker\n      map[lastIndex] = match\n      marker.lastIndex += 1\n      const m = getReplacement(name, lastIndex)\n      return m\n    },\n  }\n  return rule\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Rule} _restream.Rule\n */\n\n/* documentary types/markers.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.Marker} Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.Marker A marker is used to cut and paste portions of text to exclude them from processing by other rules. Markers should be created using the `makeMarker` factory method that will assign their properties.\n * @prop {string} name The name of the marker for annotation purposes.\n * @prop {function(string, number): string} getReplacement The function to generate marker placeholders which can be then found, e.g., for (name: `marker`, index: `10`) by default _Restream_ will generate `%%_RESTREAM_MARKER_REPLACEMENT_10_%%`, but can be overriden with this method.\n * @prop {!RegExp} re The regular expression used for detection of the match.\n * @prop {!RegExp} regExp The generated regular expression to replace the marker back to its original value.\n * @prop {!Object<number, string>} map The map which holds detected matches at their indexes.\n * @prop {number} lastIndex The index of the last inserted element. Starts with 0.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_restream.MakeMarkersConfig} MakeMarkersConfig Additional configuration.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _restream.MakeMarkersConfig Additional configuration.\n * @prop {function(string, number): string} [getReplacement] The function used to create a replacement when some text needs to be cut.\n * @prop {function(string): !RegExp} [getRegex] The function used to create a RegExp to detect replaced chunks.\n */\n","import Stream, { Transform } from 'stream'\nimport cleanStack from '@artdeco/clean-stack'\nimport { collect } from 'catchment'\nimport { checkRule, hideStack } from './lib'\n\nexport default class Replaceable extends Transform {\n  /**\n   * Replaceable class that extends Transform and pushes data when it's done replacing each incoming chunk. If the replacement is passed as a function, it will work in the same way as the replacer for `string.replace` method (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace), taking the `match` as the first argument, and matched `p1`, `p2`, _etc_ parameters as following arguments. The replacer can also be an async function.\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules A single replacement rule, or multiple rules.\n   * @param {!stream.TransformOptions} [options] The options for the transform stream.\n   * @example\n   *\n```\n// markdown __ to html <em> implementation\nconst stream = replaceStream({\n  re: /__(\\S+)__/g,\n  replacement(match, p1) {\n    return `<em>${p1}</em>`\n  },\n})\n```\n   */\n  constructor(rules, options) {\n    super(options)\n    const re = Array.isArray(rules) ? rules : [rules]\n    const fr = re.filter(checkRule)\n    this.rules = fr\n    /**\n     * Whether the _Replaceable_ will not apply any more rules.\n     * @type {boolean}\n     */\n    this._broke = false\n    this._options = options\n  }\n\n  /**\n   * Creates a new replaceable to replace the given string, buffer or stream using the rules of the current stream. Calling `brake` will also set `_broke` on the parent stream.\n   * @param {string|!Buffer|!Stream} input The input to replace.\n   * @param {!Object} [context] The context to assign to the new replaceable.\n   */\n  async replace(input, context) {\n    const replaceable = new Replaceable(this.rules, this._options)\n    if (context) Object.assign(replaceable, context)\n    const res = await Replaceable.replace(replaceable, input)\n    if (replaceable._broke) this.brake()\n    if (context) Object.keys(context).forEach(key => {\n      context[key] = replaceable[key]\n    })\n    return res\n  }\n  /**\n   * The method to end the stream with given data, and collect the result.\n   * @param {!Replaceable} replaceable\n   * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n   */\n  static async replace(replaceable, input) {\n    return replace(replaceable, input)\n  }\n\n  /**\n   * Stop executing further after the current rule.\n   */\n  brake() {\n    this._broke = true\n  }\n\n  /**\n   * @param {string|!Buffer} chunk The incoming chunk, or an object if the stream was started in object mode.\n   */\n  async reduce(chunk) {\n    /** @type {string} */\n    const s = await this.rules.reduce(async (acc, { re, replacement }) => {\n      /** @type {string} */\n      let string = await acc\n      if (this._broke) return string\n\n      if (typeof replacement == 'string') {\n        string = string.replace(re, replacement)\n      } else {\n        const promises = []\n        let commonError\n        const t = string.replace(re, (match, ...args) => {\n          commonError = new Error()\n          try {\n            if (this._broke) {\n              if (promises.length)\n                return promises.push(Promise.resolve(match))\n              return match\n            }\n            const p = replacement.call(this, match, ...args)\n            if (p instanceof Promise) {\n              promises.push(p)\n            }\n            return p\n          } catch (e) { // hide stack for sync stack traces\n            hideStack(commonError, e)\n          }\n        })\n        if (promises.length) {\n          try { // hide stack only for when throw happens before awaits\n            const data = await Promise.all(promises)\n            string = string.replace(re, () => data.shift())\n          } catch (e) {\n            hideStack(commonError, e)\n          }\n        } else {\n          string = t\n        }\n      }\n      return string\n    }, `${chunk}`)\n\n    return s\n  }\n  /**\n   * @suppress {checkTypes}\n   * @returns {!Promise}\n   */\n  async _transform(chunk, _, next) {\n    try {\n      const s = await this.reduce(chunk)\n      this.push(s)\n      next()\n    } catch (e) {\n      const s = cleanStack(e.stack)\n      e.stack = s\n      next(e)\n    }\n  }\n}\n\n/**\n * The method to end the stream with given data, and collect the result.\n * @param {!Replaceable} replaceable\n * @param {string|!Buffer|!Stream} input The data or stream to end the _Replaceable_ with.\n */\nexport async function replace(replaceable, input) {\n  if (input instanceof Stream) {\n    input.pipe(replaceable)\n  } else {\n    replaceable.end(input)\n  }\n  /** @type {string} */\n  const data = await collect(replaceable)\n  return data\n}\n\n/**\n * The class for when serial execution of asynchronous replacements withing the same rule are needed.\n */\nexport class SerialAsyncReplaceable extends Replaceable {\n  /**\n   * @param {!(_restream.Rule|Array<!_restream.Rule>)} rules\n   */\n  constructor(rules) {\n    super(rules)\n    this.promise = Promise.resolve()\n  }\n  addItem(fn) {\n    const pp = this.promise.then(fn)\n    this.promise = pp\n    return pp\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').AsyncReplacer} _restream.AsyncReplacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Replacer} _restream.Replacer\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').TransformOptions} stream.TransformOptions\n */","export const makeRe = (keys) => {\n  const k = `(${keys.join('|')})`\n  const s = '(?:\\\\s+(?!\\\\/>)[^>]*?)?' // before closing >\n  const re = new RegExp(`( *)(<${k}${s}(?:\\\\s*?/>|>[\\\\s\\\\S]*?<\\\\/\\\\3>))`, 'gm')\n  return re\n}","/**\n * @license diff package https://github.com/kpdecker/jsdiff\n * BSD License\n * Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n */\nexport default class Diff {\n  diff(oldString, newString) {\n    let self = this\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString)\n    newString = this.castInput(newString)\n\n    oldString = this.removeEmpty(this.tokenize(oldString))\n    newString = this.removeEmpty(this.tokenize(newString))\n\n    let newLen = newString.length, oldLen = oldString.length\n    let editLength = 1\n    let maxEditLength = newLen + oldLen\n    let bestPath = [{ newPos: -1, components: [] }]\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return [{ value: this.join(newString), count: newString.length }]\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath\n        let addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          oldPos = (removePath ? removePath.newPos : 0) - diagonalPath\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= oldPos && oldPos < oldLen\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined\n          continue\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath)\n          self.pushComponent(basePath.components, undefined, true)\n        } else {\n          basePath = addPath // No need to clone, we've pulled it from the list\n          basePath.newPos++\n          self.pushComponent(basePath.components, true, undefined)\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newString, oldString)\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath\n        }\n      }\n\n      editLength++\n    }\n\n    while (editLength <= maxEditLength) {\n      let ret = execEditLength()\n      if (ret) {\n        return ret\n      }\n    }\n  }\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1]\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }\n    } else {\n      components.push({ count: 1, added: added, removed: removed })\n    }\n  }\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n\n      commonCount = 0\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++\n      oldPos++\n      commonCount++\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount })\n    }\n\n    basePath.newPos = newPos\n    return oldPos\n  }\n\n  equals(left, right) {\n    return left === right\n  }\n  removeEmpty(array) {\n    let ret = []\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i])\n      }\n    }\n    return ret\n  }\n  castInput(value) {\n    return value\n  }\n  tokenize(value) {\n    return value.split('')\n  }\n  join(chars) {\n    return chars.join('')\n  }\n}\n\nfunction buildValues(diff, components, newString, oldString) {\n  let componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos]\n    if (!component.removed) {\n      if (!component.added) {\n        let value = newString.slice(newPos, newPos + component.count)\n        value = value.map(function(v, i) {\n          let oldValue = oldString[oldPos + i]\n          return oldValue.length > v.length ? oldValue : v\n        })\n\n        component.value = diff.join(value)\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count))\n      }\n      newPos += component.count\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))\n      oldPos += component.count\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1]\n        components[componentPos - 1] = components[componentPos]\n        components[componentPos] = tmp\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1]\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value\n    components.pop()\n  }\n\n  return components\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) }\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","export default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process","import { spawn, fork as forkCp } from 'child_process'\nimport { collect } from 'catchment'\n\n/**\n * @param {!child_process.ChildProcess} proc\n * @returns {!Promise<_spawncommand.PromiseResult>}\n */\nconst getPromise = async (proc) => {\n  const [code, stdout, stderr] = await Promise.all([\n    new Promise((resolve, reject) => {\n      proc.on('error', reject)\n        .on('exit', (code) => {\n          resolve(code)\n        })\n    }),\n    proc.stdout ? collect(proc.stdout) : undefined,\n    proc.stderr ? collect(proc.stderr) : undefined,\n  ])\n  return {\n    code,\n    stdout,\n    stderr,\n  }\n}\n\n/**\n * Spawns a new process using the `command` and returns an instance of a ChildProcess, extended to have a `promise` property which is resolved when the process exits. The resolved value is an object with `stdout`, `stderr` and `code` properties.\n * @param {string} command The command to run.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.SpawnOptions} [options] Options used to spawn.\n */\nexport default function spawnCommand(command, args, options) {\n  if (!command) throw new Error('Please specify a command to spawn.')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (spawn(command, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/**\n * Forks a process and assign a `promise` property to it, resolved with `stderr`, `stdout` and `code` properties on exit.\n * @param {string} mod The module to run in the child.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.ForkOptions} [options] Options to fork the process with.\n */\nexport function fork(mod, args, options) {\n  if (!mod) throw new Error('Please specify a module to fork')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (forkCp(mod, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.PromiseResult} PromiseResult\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.PromiseResult\n * @prop {string} stdout The accumulated result of the `stdout` stream.\n * @prop {string} stderr The accumulated result of the `stderr` stream.\n * @prop {number} code The code with which the process exited.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').SpawnOptions} child_process.SpawnOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ChildProcess} child_process.ChildProcess\n */\n\n/* documentary types/cp.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.ChildProcessWithPromise} ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {child_process.ChildProcess & _spawncommand.$ChildProcessWithPromise} _spawncommand.ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.$ChildProcessWithPromise A child process with an extra `promise` property.\n * @prop {!Promise<!_spawncommand.PromiseResult>} promise A promise resolved when the process exits.\n * @prop {string} spawnCommand The spawn arguments joined by whitespace.\n */\n","export default util\nexport const {\n  TextDecoder,\n  TextEncoder,\n  callbackify,\n  debug,\n  debuglog,\n  deprecate,\n  error,\n  format,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray,\n  isBoolean,\n  isBuffer,\n  isDate,\n  isError,\n  isFunction,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isPrimitive,\n  isRegExp,\n  isString,\n  isSymbol,\n  isUndefined,\n  log,\n  print,\n  promisify,\n  puts,\n} = util","/**\n * Exclude items from the array\n * @param {!Array<!Array<string>, !Array<string>>} acc left to exclude, and non-excluded\n * @param {string} current\n */\nexport const excludeReducer = (acc, current) => {\n  const [ok, ex] = acc\n  let i\n  if (!ex.length || (i = ex.indexOf(current)) == -1) {\n    return [\n      [...ok, current],\n      ex,\n    ]\n  }\n  const before = ex.slice(0, i)\n  const after = ex.slice(i + 1, -1)\n  const newExcluded = [...before, ...after]\n  return [\n    ok,\n    newExcluded,\n  ]\n}\n\nconst hasFile = (array, file) => {\n  return array.some(a => a == file)\n}\n\n/**\n * @param {!Array<string>} files\n * @param {boolean} [reverse]\n */\nexport const getKeys = (files, reverse) => {\n  const hasIndex = hasFile(files, 'index.md')\n  const hasFooter = hasFile(files, 'footer.md')\n\n  const excluded = ['index.md', 'footer.md']\n\n  const included = files.filter(f => !excluded.includes(f))\n\n  const sorted = included.sort((a, b) => {\n    const res = a.localeCompare(b, undefined, { numeric: true })\n    if (reverse) return -res\n    return res\n  })\n\n  if (hasIndex && hasFooter) {\n    return [\n      'index.md',\n      ...sorted,\n      'footer.md',\n    ]\n  }\n  if (hasIndex) {\n    return [\n      'index.md',\n      ...sorted,\n    ]\n  }\n  if (hasFooter) {\n    return [\n      ...sorted,\n      'footer.md',\n    ]\n  }\n  return sorted\n}\n","import { join } from 'path'\nimport { createReadStream } from 'fs'\nimport { PassThrough } from 'stream'\nimport { debuglog } from 'util'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport { getKeys } from './lib'\n\nconst LOG = debuglog('pedantry')\n\nconst processDir = async ({\n  stream, source, path = '.', content = {}, reverse = false,\n  separator, includeFilename, ignoreHidden,\n}) => {\n  const k = Object.keys(content)\n\n  const keys = getKeys(k, reverse)\n\n  const size = await keys.reduce(async (acc, name) => {\n    let totalSize = await acc\n    const { type, content: dirContent } = content[name]\n    const relPath = join(path, name)\n\n    let s\n    if (type == 'File') {\n      const shouldIgnore = ignoreHidden && name.startsWith('.')\n      if (!shouldIgnore) s = await processFile({\n        stream, source, path: relPath, separator, includeFilename,\n      })\n    } else if (type == 'Directory') {\n      s = await processDir({\n        stream, source, path: relPath, content: dirContent, reverse,\n        separator, includeFilename, ignoreHidden,\n      })\n    }\n    totalSize += s\n    return totalSize\n  }, 0)\n\n  LOG('dir %s size: %s B', path, size)\n  return size\n}\n\n/**\n * @param {Object} options\n * @param {Pedantry} options.stream\n */\nconst processFile = async (options) => {\n  const {\n    stream, source, path, separator, includeFilename,\n  } = options\n  const fullPath = join(source, path)\n  stream.emit('file', path)\n  if (separator && !stream.justStarted) {\n    if (includeFilename) {\n      stream.push({ file: 'separator', data: separator })\n    } else {\n      stream.push(separator)\n    }\n  }\n  const size = await new Promise((r, j) => {\n    let s = 0\n    const rs = createReadStream(fullPath)\n    rs.on('data', (d) => {\n      s += d.byteLength\n    }).on('error', (err) => {\n      j(err)\n    }).on('close', () => {\n      r(s)\n    })\n    if (includeFilename) {\n      rs.on('data', (data) => {\n        stream.push({ file: fullPath, data: `${data}` })\n      })\n    } else {\n      rs.pipe(stream, { end: false })\n    }\n  })\n  stream.justStarted = false\n  LOG('file %s :: %s B', fullPath, size)\n  return size\n}\n\n// * @todo implement reading only on read ie change mode\n\nexport default class Pedantry extends PassThrough {\n  /**\n   * Upon creation, `Pedantry` will start reading files in the `source` directory recursively in the following order: the content of the `index.md` file will go first, then of all files and directories in the folder recursively in a sorted order, and the content of the `footer.md` file will go last if found.\n   * @param {string} source Path to the root directory.\n   * @param {_pedantry.Options} [options] Options for Pedantry.\n   */\n  constructor(source, options = {}) {\n    const {\n      reverse = false,\n      addNewLine = false,\n      addBlankLine = false,\n      includeFilename = false,\n      ignoreHidden = false,\n    } = options\n    super({\n      objectMode: includeFilename,\n    })\n    let separator\n    if (addNewLine) separator = '\\n'\n    else if (addBlankLine) separator = '\\n\\n'\n    this.justStarted = true\n    ;(async () => {\n      let content\n      try {\n        ({ content } = await readDirStructure(source))\n      } catch (err) {\n        const e = new Error(err.message)\n        this.emit('error', e)\n      }\n      try {\n        await processDir({\n          stream: this,\n          source,\n          content,\n          reverse,\n          separator,\n          includeFilename,\n          ignoreHidden,\n        })\n      } catch (err) {\n        this.emit('error', err)\n      } finally {\n        this.end()\n      }\n    })()\n  }\n}\n\n// /**\n//  * A file event.\n//  * @event Pedantry#file\n//  * @param {string} file A path to the file currently being processed relative to the `Pedantry` source.\n//  */\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Options} _pedantry.Options\n */","export default _crypto\nexport const {\n  Certificate,\n  Cipher,\n  Credentials,\n  DEFAULT_ENCODING,\n  Decipher,\n  DiffieHellman,\n  ECDH,\n  Hash,\n  Hmac,\n  Verify,\n  createCipher,\n  createCipheriv,\n  createCredentials,\n  createDecipher,\n  createDecipheriv,\n  createDiffieHellman,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getHashes,\n  pbkdf2,\n  pbkdf2Sync,\n  privateDecrypt,\n  privateEncrypt,\n  pseudoRandomBytes,\n  publicDecrypt,\n  publicEncrypt,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  timingSafeEqual,\n} = _crypto","export default _module\nexport const {\n  Module,\n  builtinModules,\n  runMain,\n  wrap,\n} = _module","import mismatch from 'mismatch'\n\nconst RE = /^ *import(?:\\s+(?:[^\\s,]+)\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE2 = /^ *import\\s+(?:.+?\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE3 = /^ *import\\s+(['\"])(.+?)\\1/gm\nconst RE4 = /^ *export\\s+(?:{[^}]+?}|\\*)\\s+from\\s+(['\"])(.+?)\\1/gm\n\n/**\n * Returns the names of the modules imported with `import` and `export` statements.\n * @param {string} source The source to detect matches in.\n */\nconst getMatches = (source) => {\n  const res = [RE, RE2, RE3, RE4].reduce((acc, re) => {\n    const m = mismatch(re, source, ['q', 'from'])\n      .map(a => a['from'])\n    return [...acc, ...m]\n  }, [])\n  return res\n}\n\nexport default getMatches\n\nexport const RES = {\n  RE, RE2, RE3, RE4,\n}","import { join, relative, resolve, dirname } from 'path'\nimport exists from '@wrote/exists'\nimport read from '@wrote/read'\nimport resolveDep from 'resolve-dependency'\n\n/**\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\n * @param {string} dir The path to the directory where the requiring file is located.\n * @param {string} name The name of the required package.\n * @param {!_fpj.Config} opts The options for `fpj`.\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n * @returns {!Promise<!_fpj.Return>}\n */\nconst findPackageJson = async (dir, name, opts = {}) => {\n  const { fields, soft = false } = opts\n  const fold = join(dir, 'node_modules', name)\n  const path = join(fold, 'package.json')\n  const e = await exists(path)\n  if (e) {\n    const res = await findEntry(path, fields)\n    if (res === undefined)\n      throw new Error(`The package ${relative('', path)} does export the module.`)\n    else if (!res.entryExists && !soft)\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\n    const { entry, version, packageName, main, entryExists, ...rest } = res\n    const result = /** @type {!_fpj.Return} */ ({\n      entry: relative('', entry),\n      packageJson: relative('', path),\n      ...(version ? { version } : {}),\n      packageName,\n      ...(main ? { hasMain: true } : {}),\n      ...(!entryExists ? { entryExists: false } : {}),\n      ...rest,\n    })\n    return result\n  }\n  if (dir == '/' && !e)\n    throw new Error(`Package.json for module ${name} not found.`)\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\n}\n\n/**\n * Finds the path to the entry based on package.json file.\n * @param {string} path\n * @param {!Array<string>} fields\n */\nexport const findEntry = async (path, fields = []) => {\n  const f = await read(path)\n  let mod, version, packageName, main, rest\n  try {\n    ({\n      'module': mod,\n      'version': version,\n      'name': packageName,\n      'main': main,\n      ...rest\n    } = JSON.parse(f))\n    rest = fields.reduce((acc, current) => {\n      acc[current] = rest[current]\n      return acc\n    }, {})\n  } catch (err) {\n    throw new Error(`Could not parse ${path}.`)\n  }\n  const dir = dirname(path)\n  let resolved = mod || main\n  if (!resolved) {\n    const indexExists = await exists(join(dir, 'index.js'))\n    if (!indexExists) return undefined\n    resolved = main = 'index.js'\n  }\n  let entry = join(dir, resolved)\n  let r\n  try {\n    ({ path: r } = await resolveDep(entry))\n    entry = r\n  } catch (err) {/* does not exist */}\n  return { entry, version, packageName, main: !mod && main,\n    entryExists: !!r,\n    ...rest }\n}\n\nexport default findPackageJson\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Config} Config The options for `fpj`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Config The options for `fpj`.\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Return} Return The return type of the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Return The return type of the program.\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\n * @prop {string} packageJson The path to the package.json file itself.\n * @prop {string} packageName The name of the resolved package.\n * @prop {string} [version] The version of the package.\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\n */\n","import { dirname, join } from 'path'\nimport { builtinModules } from 'module'\nimport read from '@wrote/read'\nimport resolveDependency from 'resolve-dependency'\nimport getMatches from '@depack/detect'\nimport split from '@depack/split'\nimport findPackageJson from 'fpj'\nimport mismatch from 'mismatch'\nimport erotic from 'erotic'\n\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\n/**\n * Expands the dependency match to include `package.json` and entry paths.\n * @param {string} path The path to the file.\n * @param {!Array<string>} matches The matches.\n * @param {boolean} [soft] Whether to throw when a dependency's package.json is not found.\n * @param {!Array<string>} [fields] What additional fields to fetch from package.json.\n * @returns {!Promise<!Array<!_staticAnalysis.DependencyMeta>>}\n */\nconst getDependenciesMeta = async (path, matches, soft, fields, pckg = null) => {\n  const e = erotic()\n  const dir = dirname(path)\n  const proms = matches.map(async (name) => {\n    const internal = builtinModules.includes(name)\n    if (internal) return { internal: name }\n    const isLib = checkIfLib(name)\n    if (isLib) {\n      try {\n        const { path: entry } = await resolveDependency(name, path)\n        return { entry, package: pckg }\n      } catch (err) { /*\n        maybe a local package with package.json\n      */}\n    } else {\n      const { name: n, paths } = split(name)\n      if (paths) {\n        const { packageJson, packageName } = await findPackageJson(dir, n)\n        const d = dirname(packageJson)\n        const { path: entry } = await resolveDependency(join(d, paths))\n        return { entry, package: packageName }\n      }\n    }\n    try {\n      const {\n        entry, packageJson, version, packageName, hasMain, ...rest\n      } = await findPackageJson(dir, name, { fields })\n      if (packageName == pckg) {\n        console.warn('[static-analysis] Skipping package %s that imports itself in %s', packageName, path)\n        return null\n      }\n      return {\n        entry, packageJson, version, name: packageName,\n        ...(hasMain ? { hasMain } : {}),\n        ...rest }\n    } catch (err) {\n      if (soft) return null\n      throw e(err)\n    }\n  })\n  return (await Promise.all(proms)).filter(Boolean)\n}\n\n/**\n * Detects the imports.\n * @param {string} path\n * @param {Object} cache\n * @returns {!Promise<!Array<!_staticAnalysis.Detection>>}\n */\nexport const detect = async (path, cache = {}, {\n  nodeModules = true, shallow = false, soft = false, fields = [],\n  package: pckg } = {}) => {\n  if (path in cache) return []\n  cache[path] = 1\n  const source = await read(path)\n  const matches = getMatches(source)\n  const requireMatches = getRequireMatches(source)\n  const fm = nodeModules ? matches : matches.filter(checkIfLib)\n  const fr = nodeModules ? requireMatches : requireMatches.filter(checkIfLib)\n\n  let deps\n  try {\n    const dm = await getDependenciesMeta(path, fm, soft, fields, pckg)\n    const rm = await getDependenciesMeta(path, fr, soft, fields, pckg)\n    rm.forEach((val) => {\n      val.required = true\n    })\n    deps = [...dm, ...rm]\n  } catch (err) {\n    err.message = `${path}\\n [!] ${err.message}`\n    throw err\n  }\n  const d = deps.map(o => ({ ...o, from: path }))\n  const entries = deps\n    .filter(({ entry }) => entry && !(entry in cache))\n  const discovered = await entries\n    .reduce(async (acc, {\n      entry, hasMain, packageJson, name, package: p }) => {\n      if (packageJson && shallow) return acc\n      const accRes = await acc\n      const res = await detect(entry, cache, { nodeModules, shallow, soft, fields, package: name || p })\n      const r = res\n        .map(o => ({\n          ...o,\n          from: o.from ? o.from : entry,\n          ...(!o.packageJson && hasMain ? { hasMain } : {}),\n        }))\n      return [...accRes, ...r]\n    }, d)\n  return discovered\n}\n\nexport const getRequireMatches = (source) => {\n  const m = mismatch(/(?:^|[^\\w\\d_])require\\(\\s*(['\"])(.+?)\\1\\s*\\)/gm, source, ['q', 'from'])\n  const res = m.map(a => a['from'])\n  return res\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').Detection} _staticAnalysis.Detection\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('.').DependencyMeta} _staticAnalysis.DependencyMeta\n */","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","import resolveDependency from 'resolve-dependency'\nimport erotic from 'erotic'\nimport { detect } from './lib'\n\n/**\n * Detects all dependencies in a file and their dependencies recursively.\n * @param {string} path The path to the file in which to detect dependencies.\n * @param {!_staticAnalysis.Config} [config] The configuration options for `staticAnalysis`.\n * @param {boolean} [config.nodeModules=true] Whether to include packages from `node_modules` in the output. Default `true`.\n * @param {boolean} [config.shallow=false] Only report on the entries of `node_module` dependencies, without analysing their own dependencies. Default `false`.\n * @param {boolean} [config.soft=false] Do not throw an error when the dependency cannot be found in `node_modules`. Default `false`.\n * @param {!Array<string>} [config.fields] Any additional fields from `package.json` files to return.\n * @return {!Promise<!Array<!_staticAnalysis.Detection>>} The array with detections.\n */\nconst staticAnalysis = async (path, config = {}) => {\n  const e = erotic()\n  const { path: p } = await resolveDependency(path)\n  const {\n    nodeModules = true,\n    shallow = false,\n    soft = false,\n    fields = [],\n  } = config\n  let detected\n  try {\n    detected = await detect(p, {}, {\n      nodeModules, shallow, soft, fields })\n  } catch (err) {\n    throw e(err)\n  }\n  const filtered = detected.filter(({ internal, entry }, i) => {\n    if (internal) {\n      const fi = detected.findIndex(({ internal: ii }) => {\n        return ii == internal\n      })\n      return fi == i\n    }\n    const ei = detected.findIndex(({ entry: ee }) => {\n      return entry == ee\n    })\n    return ei == i\n  })\n  const f = filtered.map((ff) => {\n    const { entry, internal } = ff\n    const froms = detected\n      .filter(({ internal: i, entry: ee }) => {\n        if (internal) return internal == i\n        if (entry) return entry == ee\n      })\n      .map(({ from }) => from)\n      .filter((el, i, a) => a.indexOf(el) == i)\n    const newF =  { ...ff, from: froms }\n    return newF\n  })\n    .map(({ package: pckg, ...props }) => {\n      if (pckg) return { package: pckg, ...props }\n      return props\n    })\n  return f\n}\n\n/**\n * Sorts the detected dependencies into commonJS modules, packageJsons and internals.\n * @param {!Array<!_staticAnalysis.Detection>} detected The detected matches\n */\nexport const sort = (detected) => {\n  const packageJsons = []\n  const commonJsPackageJsons = []\n  const commonJs = []\n  const js = []\n  const internals = []\n  const deps = []\n  detected\n    .forEach(({ packageJson, hasMain, name, entry, internal }) => {\n      if (internal) return internals.push(internal)\n\n      if (packageJson && hasMain)\n        commonJsPackageJsons.push(packageJson)\n      else if (packageJson) packageJsons.push(packageJson)\n      if (entry && hasMain) commonJs.push(entry)\n      else if (entry) js.push(entry)\n      if (name) deps.push(name)\n    })\n  return { commonJsPackageJsons,\n    packageJsons, commonJs, js, internals, deps }\n}\n\nexport default staticAnalysis\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_staticAnalysis.Config} Config The configuration options for `staticAnalysis`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _staticAnalysis.Config The configuration options for `staticAnalysis`.\n * @prop {boolean} [nodeModules=true] Whether to include packages from `node_modules` in the output. Default `true`.\n * @prop {boolean} [shallow=false] Only report on the entries of `node_module` dependencies, without analysing their own dependencies. Default `false`.\n * @prop {boolean} [soft=false] Do not throw an error when the dependency cannot be found in `node_modules`. Default `false`.\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` files to return.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_staticAnalysis.Detection} Detection The module detection result.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _staticAnalysis.Detection The module detection result.\n * @prop {string} [entry] The path to the JavaScript file to be required. If an internal Node.js package is required, it's name is found in the `internal` field.\n * @prop {!Array<string>} from The file in which the dependency was found.\n * @prop {string} [packageJson] The path to the `package.json` file of the dependency if it's a module.\n * @prop {string} [name] The name of the package.\n * @prop {string} [version] The version of the package.\n * @prop {string} [internal] If it's an internal NodeJS dependency, such as `fs` or `path`, contains its name.\n * @prop {boolean} [hasMain] Whether the entry from the package was specified via the `main` field and not `module` field.\n * @prop {string} [package] If the entry is a library file withing a package, this field contains its name. Same as the `name` field for the _main/module_ entries.\n * @prop {boolean} [required] Whether the package was required using the `require` statement.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_staticAnalysis.DependencyMeta} DependencyMeta\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _staticAnalysis.DependencyMeta\n * @prop {string} [internal] The name of the internal Node.JS package.\n * @prop {string} [packageJson] The location of the _package.json_ file.\n * @prop {string} [entry] The entry to the package (module or main fields).\n * @prop {string} [package] The package the entry belongs to.\n * @prop {boolean} [hasMain] Whether the dependency has main field.\n * @prop {boolean} [required] Whether the dependency was required.\n */\n","import staticAnalysis from 'static-analysis'\nimport resolveDependency from 'resolve-dependency'\nimport { c } from 'erte'\nimport { lstat } from 'fs'\nimport makePromise from 'makepromise'\n\nexport const compareHash = (currentHash, hash, log = console.log) => {\n  const added = []\n  const removed = []\n  hash.forEach((mm) => {\n    if (!currentHash.includes(mm)) {\n      added.push(mm)\n    }\n  })\n  currentHash.forEach((mm) => {\n    if (!hash.includes(mm)) {\n      removed.push(mm)\n    }\n  })\n  const changed = added.length || removed.length\n\n  if (!changed) return true\n  added.forEach((mm) => {\n    const { entry, mmeta } = getMetaToPrint(mm)\n    log(c('+', 'green'), entry, mmeta)\n  })\n  removed.forEach((mm) => {\n    const { entry, mmeta } = getMetaToPrint(mm)\n    log(c('-', 'red'), entry, mmeta)\n  })\n  return false\n}\n\nconst getMetaToPrint = (mm) => {\n  const [entry, meta] = mm.split(' ')\n  let mmeta = ''\n  if (meta) {\n    mmeta = /^\\d+$/.test(meta) ? new Date(parseInt(meta, 10)).toLocaleString() : meta\n  }\n  return { entry, mmeta }\n}\n\nexport const getMtime = async (entry) => {\n  const stat = /** @type {!fs.Stats} */ (await makePromise(lstat, entry))\n  const mtime = stat.mtime\n  return mtime.getTime()\n}\n\nexport const computeHash = async (analysis) => {\n  const hash = await Promise.all(analysis.map(async ({ entry, name, internal, version }) => {\n    if (name) return `${name} ${version}`\n    if (internal) return internal\n    const mtime = await getMtime(entry)\n    return `${entry} ${mtime}`\n  }))\n  return hash\n}\n\n\nexport const analyse = async (mod) => {\n  const analysis = await staticAnalysis(mod, {\n    shallow: true,\n    soft: true,\n  })\n  const hash = await computeHash(analysis)\n\n  const { path: mmod } = await resolveDependency(mod)\n  const mmtime = await getMtime(mmod)\n\n  return { mtime: mmtime, hash, analysis }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import Catchment from 'catchment'\nimport { createWriteStream, createReadStream } from 'fs'\nimport { Writable } from 'stream'\n\n/**\n * Handles the flow of streams, and awaits for them to complete. The input can be specified either as a string with the `source` property, or as as stream with the `readable`. The output can also be given either as a string with the `destination`, or as a stream with the `writable`. If destination is passed as the `-`, the output becomes `process.stdout`.\n * @param {!_whichStream.Config} config The configuration object.\n */\nasync function whichStream(config) {\n  const {\n    source,\n    destination,\n  } = config\n  let { readable, writable } = config\n\n  if (!(source || readable))\n    throw new Error('Please give either a source or readable.')\n  if (!(destination || writable))\n    throw new Error('Please give either a destination or writable.')\n\n  if (source && !readable) readable = createReadStream(source)\n\n  if (destination == '-') {\n    readable.pipe(process.stdout)\n  } else if (destination) {\n    await handleWriteStream(destination, readable, source)\n  } else if (writable instanceof Writable) {\n    readable.pipe(writable)\n    await new Promise((r, j) => {\n      writable.on('error', j)\n      writable.on('finish', r)\n    })\n  }\n}\n\nconst handleWriteStream = async (destination, readable, source) => {\n  if (readable.path == destination || source == destination) {\n    const { promise } = new Catchment({ rs: readable })\n    const res = await promise\n    await new Promise((r, j) => {\n      // must create writable after reading\n      const writable = createWriteStream(destination)\n      writable\n        .once('error', j)\n        .end(res, r)\n    })\n  } else {\n    await new Promise((r, j) => {\n      const writable = createWriteStream(destination)\n      readable.pipe(writable)\n      writable\n        .once('error', j)\n        .on('close', r)\n    })\n  }\n}\n\nexport default whichStream\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Config} _whichStream.Config\n */\n","import '@externs/preact'\nimport write from '@wrote/write'\nimport read from '@wrote/read'\nimport clone from '@wrote/clone'\nimport ensurePath from '@wrote/ensure-path'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport rexml from 'rexml'\nimport argufy, { reduceUsage } from 'argufy'\nimport Catchment, { collect } from 'catchment'\nimport clearr from 'clearr'\nimport competent from 'competent'\nimport erte, { c, b } from 'erte'\nimport forkfeed from 'forkfeed'\nimport makepromise from 'makepromise'\nimport mismatch from 'mismatch'\nimport usually from 'usually'\nimport resolveDependency from 'resolve-dependency'\nimport spawn, { fork } from 'spawncommand'\nimport {\n  SyncReplaceable, Replaceable, makeMarkers, makeCutRule, makePasteRule,\n  replace,\n} from 'restream'\nimport Pedantry from 'pedantry'\nimport compare from '@depack/cache'\nimport whichStream from 'which-stream'\n\nmodule.exports = {\n  'competent': competent,\n  'c': c,\n  'b': b,\n  'readDirStructure': readDirStructure,\n  'clone': clone,\n  'Pedantry': Pedantry,\n  'whichStream': whichStream,\n  'compare': compare,\n  'ensurePath': ensurePath,\n  'read': read,\n  'replace': replace,\n  'usually': usually,\n  'spawn': spawn,\n  'fork': fork,\n  'SyncReplaceable': SyncReplaceable,\n  'Replaceable': Replaceable,\n  'makeMarkers': makeMarkers,\n  'makeCutRule': makeCutRule,\n  'makePasteRule': makePasteRule,\n  'resolveDependency': resolveDependency,\n  'rexml': rexml,\n  'reduceUsage': reduceUsage,\n  'write': write,\n  'argufy': argufy,\n  'Catchment': Catchment,\n  'collect': collect,\n  'clearr': clearr,\n  // 'competent': competent,\n  'erte': erte,\n  'forkfeed': forkfeed,\n  'makepromise': makepromise,\n  'mismatch': mismatch,\n}","import render from '@depack/render'\nimport rexml from 'rexml'\nimport { Replaceable } from 'restream'\nimport { makeRe } from './lib'\n\n/**\n * Extracts, Renders And Exports For Dynamic Render JSX Components From Within HTML.\n * @param {!Object<string, function({ children: !Array<string> })>} components The components to look for and render.\n * @param {!_competent.Config} [conf] Options for the program. All functions will be called with the Replaceable instance as their `this` context.\n */\nconst competent = (components, conf = {}) => {\n  const { getId, getProps = (props, meta) => ({\n    ...props, ...meta }), markExported, onSuccess, onFail,\n  removeOnError = false, getContext, getReplacements } = conf\n\n  const re = makeRe(Object.keys(components))\n\n  /** @type {!_restream.AsyncReplacer} */\n  const replacement = async function (m, pad, Component, key, position, str) {\n    try {\n      const instance = components[key]\n      const before = str.slice(0, position)\n      const after = str.slice(position + m.length)\n      if (/\u003c!--\\s*$/.test(before) && /^\\s*--\u003e/.test(after))\n        return m\n\n      // let initialPadding = 0\n      // const lastNewLine = before.lastIndexOf('\\n')\n      // if (lastNewLine != -1) initialPadding = position - lastNewLine - 1\n      // else initialPadding = position\n\n      const [{ content = '', props: htmlProps }] = rexml(key, Component)\n      let child = content\n      if (child) {\n        const r = new Replaceable({ re, replacement })\n        if (getContext) {\n          const ctx = getContext.call(this)\n          Object.assign(r, ctx)\n        }\n        child = await Replaceable.replace(r, child)\n      }\n      const children = [child]\n      let exported = false\n      let renderAgain = false\n      let recursiveRenderAgain = false\n      let pretty, lineLength\n      let id\n      const props = getProps.call(this, {\n        ...htmlProps,\n        children,\n      }, /** @type {!_competent.Meta} */ ({\n        export(value = true) { exported = value },\n        setPretty(p, l) { pretty = p; if (l) lineLength = l },\n        renderAgain(v = false) { renderAgain = true, recursiveRenderAgain = v },\n      }), key)\n      /** @type {preact.VNode} */\n      let hyperResult\n      try {\n        const promise = instance(props)\n        hyperResult = await promise\n      } catch (err) {\n        if (!err.message.startsWith('Class constructor'))\n          throw err\n        const Instance = /** @type {function(new:preact.Component)} */ (instance)\n        const i = new Instance()\n        hyperResult = i.render(props)\n      }\n      if (exported && !hyperResult.attributes.id) {\n        id = getId.call(this) // `c${splendid.random()}`\n        hyperResult.attributes.id = id\n      }\n      const renderOptions = {\n        pretty,\n        lineLength,\n      }\n      let r\n      if (typeof hyperResult == 'string') {\n        r = hyperResult\n      } else if (Array.isArray(hyperResult)) {\n        r = hyperResult.map((hr) => {\n          if (typeof hr == 'string') return hr\n          const res = render(hr, renderOptions)\n          return res\n        }).join('\\n')\n      } else {\n        r = render(hyperResult, renderOptions)\n      }\n      r = r.replace(/^/gm, pad)\n      if (renderAgain) {\n        let childRules\n        if (getReplacements) {\n          childRules = getReplacements.call(this, key, recursiveRenderAgain)\n        } else {\n          childRules = { re, replacement }\n        }\n        const childRepl = new Replaceable(childRules)\n        if (getContext) {\n          const ctx = getContext.call(this)\n          Object.assign(childRepl, ctx)\n        }\n        r = await Replaceable.replace(childRepl, r)\n      }\n      if (exported)\n        markExported.call(this, key, hyperResult.attributes.id, htmlProps, children)\n      if (onSuccess) onSuccess.call(this, key)\n      return r\n    } catch (err) {\n      if (onFail) onFail.call(this, key, err, position, str)\n      if (removeOnError) return ''\n      return m\n    }\n  }\n  /** @type {_restream.Rule} */\n  const rule = {\n    re, replacement,\n  }\n  return rule\n}\n\nexport default competent\nexport { default as makeComponentsScript } from './make-comps'\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('restream').Rule} _restream.Rule\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('restream').AsyncReplacer} _restream.AsyncReplacer\n */\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Config} _competent.Config\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Meta} _competent.Meta\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').VNode} preact.VNode\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Component} preact.Component\n */\n","import { createHash } from 'crypto'\nimport { compareHash, analyse } from './lib'\n\n/**\n * Computes Necessary Information To Cache A Module, And Allows To Check If It Has Been Updated.\n * @param {string} mod The path to the module to look into.\n * @param {_depack.Cache} cache The current cache.\n * @param {!Function} [log] The function to use to print updated bits of hash, such as sources.\n */\nconst compare = async (mod, cache = {}, log = console.log) => {\n  const current = cache[mod]\n  const { mtime, hash } = await analyse(mod)\n\n  const md5 = createHash('md5').update(JSON.stringify(hash)).digest(\"hex\")\n\n  if (!current) return {\n    result: false, reason: 'NO_CACHE', mtime, hash, md5,\n  }\n\n  const {\n    'mtime': currentMtime,\n    'hash': currentHash,\n  } = current\n\n  if (mtime != currentMtime) return {\n    result: false, reason: 'MTIME_CHANGE', mtime, hash, currentMtime, md5,\n  }\n  const isHashSame = compareHash(currentHash, hash, log)\n  if (isHashSame ) return { result: true, md5 }\n\n\n  return { result: false, mtime, hash, reason: 'HASH_CHANGE', md5 }\n}\n\nexport default compare\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Cache} _depack.Cache \n */","/**\n * Generate a usage string.\n * @param {!_usually.Config} config The configuration object.\n * @param {!Object<string, string>} config.usage The map with possible arguments (flags, options) and their information.\n * @param {string} [config.description] What does the program do?\n * @param {string} [config.line] The summary of the program in one line.\n * @param {string} [config.example] The example of the program usage.\n * @example\n```\nimport usually from 'usually'\n\nconst res = usually({\n  usage: {\n    '-h': 'print help',\n    '-c': 'execute this command',\n  },\n  description: 'A test command-line application',\n  line: 'usually [-c command|command2] [-h]',\n  example: 'usually -c command2',\n})\n// A test command-line application\n//\n//  usually [-c command|command2] [-h]\n//\n//        -h      print help\n//        -c      execute this command\n//\n//  Example:\n//\n//    usually -c command2\n//\n```\n */\nexport default function usually(config = { usage: {} }) {\n  const {\n    usage = {},\n    description,\n    line,\n    example,\n  } = config\n  const commands = Object.keys(usage)\n  const descriptions = Object.values(usage)\n\n  const [commandLength] = commands.reduce(([longestName = 0, longestDescription = 0], name) => {\n    const command = usage[name]\n    const theLongest = command.split('\\n')\n      .reduce((acc, c) => {\n        if (c.length > acc) return c.length\n        return acc\n      }, 0)\n    if (theLongest > longestDescription) longestDescription = theLongest\n    if (name.length > longestName) longestName = name.length\n    return [longestName, longestDescription]\n  }, [])\n\n  const pad = (string, length) => {\n    const l = length - string.length\n    const ts = ' '.repeat(l)\n    const s = `${string}${ts}`\n    return s\n  }\n\n  const usa = commands.reduce((acc, command, i) => {\n    const value = descriptions[i]\n    const vals = value.split('\\n')\n    const c = pad(command, commandLength)\n    const [firstVal, ...otherVals] = vals\n    const firstLine = `${c}\\t${firstVal}`\n    const emptyPad = pad('', commandLength)\n    const otherLines = otherVals.map(val => {\n      const r = `${emptyPad}\\t${val}`\n      return r\n    })\n    const res = [...acc, firstLine, ...otherLines]\n    return res\n  }, [])\n\n  const USA = usa.map(a => `\\t${a}`)\n  const s = [\n    description,\n    `  ${line || ''}`,\n  ].filter(l => l ? l.trim() : l).join('\\n\\n')\n  const u = `${s ? `${s}\\n` : ''}\n${USA.join('\\n')}\n`\n\n\n  if (example) {\n    return `${u}\n  Example:\n\n    ${example}\n`\n  }\n\n  return u\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_usually.Config} Config The configuration object.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _usually.Config The configuration object.\n * @prop {!Object<string, string>} usage The map with possible arguments (flags, options) and their information.\n * @prop {string} [description] What does the program do?\n * @prop {string} [line] The summary of the program in one line.\n * @prop {string} [example] The example of the program usage.\n */\n","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","/**\n * Clears the carriage return like the terminal would.\n * @param {string} string The string with the `\\r`.\n * @example\n * const res = clearR('...\\r..?\\r.!')\n * // output: .!?\n */\nconst clearR = (string) => {\n  const st = string.split('\\n').map(l => {\n    const r = l.split('\\r')\n    const t = r.reduce((acc, current, i) => {\n      if (!i) return acc\n      const { length } = current\n      const after = acc.slice(length)\n      return `${current}${after}`\n    }, r[0])\n    return t\n  }).join('\\n')\n  return st\n}\n\nexport default clearR","/**\n * Write data to the `writable` when data from the `readable` matches the regexp.\n * @param {!stream.Readable} readable A readable stream to detect data on.\n * @param {!stream.Writable} stdin A writable stream to pass answers to.\n * @param {!Array<!Array<(!RegExp|string)>>} inputs A serial collection of answers. Each answer will be ended with a `\\n` character. For example, `[[/question/, 'answer'], [/question2/, 'answer2]]`.\n * @param {stream.Writable} [log] A stream to which to write both data from readable, and the passed answer.\n */\nconst forkFeed = (readable, stdin, inputs = [], log = null) => {\n  if (log) readable.on('data', d => log.write(d))\n\n  let [a, ...rest] = inputs\n  if (!a) return\n\n  const handler = (d) => {\n    const [regexp, answer] = a\n    if (!regexp.test(d)) return\n\n    const an = `${answer}\\n`\n    if (log) log.write(an)\n\n    stdin.write(an)\n    ;([a, ...rest] = rest)\n    if (!a) readable.removeListener('data', handler)\n  }\n  readable.on('data', handler)\n}\n\nexport default forkFeed\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Writable} stream.Writable\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n"],
"names":["createReadStream","createWriteStream","lstat","mkdir","readdir","readlink","symlink","fs","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","$jscompDefaultExport","stream","PassThrough","Transform","Writable","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","read","path","checkArgumentIndex","i","makePromise","fn","resolveValue","fnLength","resolve","reject","err","error","allArgs","Array","isArray","forEach","arg","basename","dirname","relative","ensurePath","dir","make","code","parentDir","lstatFiles","dirPath","dirContent","readFiles","relativePath","ls","all","isDirectory","lstatRes","isNotDirectory","readDirStructure","lsr","directories","files","notDirectories","reduce","acc","current","isFile","isSymbolicLink","type","dirs","structure","content","cloneFile","to","ws","cloneLn","target","cloneDir","pr","keys","k","p","pt","mismatch","string","addPositions","position","start","o","capturedGroup","key","attributeRe","nameRe","valRe","attributesRe","extractTags","tag","t","tags","matches","simple","end1","end2","tagName","attributes","attrs","props","extractProps","simpleAttribute","val","parseInt","find","argv","long","short","bool","number","findIndex","a","value","startsWith","findTitles","titles","IS_NON_DIMENSIONAL","encodeEntities","s","isLargeString","JS_TO_CSS","getNodeProps","vnode","children","defaultProps","nodeName","mapAttributes","allAttributes","xml","isSvgMode","sort","selectValue","html","mappedAttributes","name","v","class","for","srcset","toLowerCase","str","prop","__html","Boolean","UNNAMED","VOID_ELEMENTS","INLINE_ELEMENTS","render","config","addDoctype","renderToString","context","inner","shallow","renderRootComponent","shallowHighOrder","sortAttributes","initialPadding","closeVoidTags","lineLength","noPretty","ip","repeat","indentChar","prototype","c","_disable","__x","getDerivedStateFromProps","state","componentWillMount","rendered","getChildContext","displayName","Function","getFallbackComponentName","cl","nl","newLength","isVoid","pieces","getLastLineLength","hasLarge","child","ret","childSvgMode","substring","lastPiece","component","toString","call","index","st","lastLine","checkRule","reObject","replacement","hasRe","hideStack","commonError","thrownError","commonLine","substr","li","lastIndexOf","SyncReplaceable","input","rules","fr","_broke","Acc","brake","replace.brake","getDefaultRegExp","toUpperCase","getDefaultReplacement","replaceable","Replaceable","_options","Replaceable$$module$node_modules$restream$src$Replaceable.replace","promises","data","shift","next","Stream","end","makeRe","pushComponent","components","added","removed","last","count","extractCommon","basePath","newString","oldString","diagonalPath","newLen","oldLen","newPos","oldPos","commonCount","equals","removeEmpty","array","diff","Diff","editLength","maxEditLength","bestPath","addPath","removePath","canAdd","canRemove","self","buildValues","left","right","chars","componentPos","componentLen","tmp","oldValue","lastComponent","pop","colors","backgroundColors","color","cc","b","exists","resolveDependency","relativeFrom","isDir","checkSources","fileChecked","fileRes","endsWith","pp","fork","spawn","child_process","getPromise","proc","stdout","stderr","debuglog","util","hasFile","file","some","getKeys","reverse","hasIndex","hasFooter","excluded","sorted","included","f","localeCompare","numeric","LOG","processDir","separator","includeFilename","ignoreHidden","size","totalSize","relPath","processFile","fullPath","justStarted","byteLength","Pedantry","addNewLine","addBlankLine","objectMode","createHash","_crypto","builtinModules","_module","RE","RE2","RE3","RE4","getMatches","findPackageJson","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","mod","JSON","parse","resolved","indexExists","checkIfLib","modName","getDependenciesMeta","pckg","proms","internal","isLib","package","scope","paths","n","console","warn","detect","cache","nodeModules","requireMatches","getRequireMatches","fm","deps","dm","rm","required","discovered","entries","accRes","staticAnalysis","detected","filtered","fi","ii","ei","ee","ff","froms","el","newF","compareHash","currentHash","hash","log","mm","mmeta","getMetaToPrint","meta","toLocaleString","Date","getMtime","mtime","stat","getTime","computeHash","analysis","analyse","mmod","mmtime","handleWriteStream","destination","writable","module","exports","conf","competent","pad","Component","instance","before","after","htmlProps","getContext","ctx","exported","renderAgain","recursiveRenderAgain","id","getProps","export","setPretty","l","hyperResult","getId","renderOptions","hr","childRules","getReplacements","childRepl","markExported","onSuccess","onFail","removeOnError","rule","clone","whichStream","process","compare","md5","update","stringify","digest","reason","currentMtime","isHashSame","usually","usage","description","line","example","commands","descriptions","values","commandLength","longestName","longestDescription","theLongest","command","ts","USA","usa","vals","firstVal","otherVals","firstLine","emptyPad","otherLines","u","spawnCommand","forkCp","matchers","makeMarkers","getReplacement","getRegex","regExp","lastIndex","marker","makeCutRule","pipeRules","makePasteRule","argsConfig","reduceUsage","default","write","argufy","commandFound","_argv","boolean","multiple","clearR","erte","stdin","inputs","forkFeed","handler","regexp","answer","an","removeListener","makepromise"]
}
